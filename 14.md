The text **"OperÃ¡ciÃ³s rendszerek gyakorlat"** translates to:

**"Operating Systems Practice"** in English.

Here's a detailed explanation of the slide content translated and expanded:

---

### **What will we learn about?**

#### â— Using one of the most common command interpreters (the Bash shell) in Linux/Unix systems:
- **Essential commands**  
  You will learn frequently used commands in the terminal (e.g., `ls`, `cd`, `cp`, `mv`, `rm`, etc.) which are vital for interacting with the system.

- **"One-liner programs"**  
  These are short, powerful command combinations written in a single line (often using pipes `|`, redirection, etc.) to automate tasks or process data quickly.

- **Shell scripts (hÃ©jprogramok)**  
  These are script files written in Bash that automate a sequence of commands. Youâ€™ll learn how to write and execute them for more complex automation.

#### â— About the Perl programming language:
- **Basic syntax**  
  Introduction to how Perl code is writtenâ€”variables, data types, control structures (like `if`, `for`, etc.).

- **Important functions**  
  Learning key built-in functions that make Perl powerful for tasks like text processing, file handling, and more.

---

This slide is part of a practical course titled *"OperÃ¡ciÃ³s rendszerek gyakorlat"* ("Operating Systems Practice") and seems to focus on essential scripting skills for system administration or automation tasks.


Here is the translation and explanation of the slide titled **"MiÃ©rt kell ez nekÃ¼nk?"** â€“ *"Why do we need this?"*:

---

### **Why do we need this?**

- **(Besides the fact that there are assignments and quizzes based on this...)**  
  It humorously notes that this knowledge is required for course tasks and evaluations.

- **There are far more Linux/Unix systems running than most people think.**  
  Some tasks can only be solved via the terminal. Sooner or later, youâ€™re likely to encounter these situations.

- **The terminal is highly efficient for daily tasks.**  
  Itâ€™s a flexible environment and can provide very concise solutions to many problems.

- **For writing one-time-use programs, and for system administration...**  
  This suggests the utility of scripting in automating tasks or solving problems quickly without building full applications.

- **To get familiar with scripting languages.**  
  Learning scripting helps broaden your programming and system interaction skills.

---

This slide is essentially arguing for the practical relevance and long-term usefulness of terminal and scripting skills, especially in real-world IT, system admin, and development tasks.

### TL;DR â€“ **Where can we practice?**

You can practice **anywhere Bash is available**, including:

- **Glomer** â€“ the official platform for assignments and tests.
- **Your own Linux system** â€“ useful for other courses too.
- **Virtual machine** â€“ safe to experiment since mistakes donâ€™t harm the host system.
- **Live system** â€“ can practice on a borrowed machine without leaving traces.


### **Additional Help**

Here are some useful resources to support your learning:

- [linuxconfig.org Bash scripting tutorial for beginners](https://linuxconfig.org/bash-scripting-tutorial-for-beginners)  
  Great for learning basic Bash scripting from scratch.

- [perltutorial.org](https://www.perltutorial.org)  
  A dedicated site for learning Perl programming.

- [TutorialsPoint Perl guide](https://www.tutorialspoint.com/perl/index.htm)  
  Another comprehensive Perl tutorial.

- **(Catch-up sessions)**  
  Implies that extra help or remedial sessions might be available if you fall behind.

---

These resources are great for self-study alongside the course material.


Hereâ€™s the translated and summarized content of the slide titled **"BelÃ©pÃ©s egy Unix rendszerbe"** â€“ *"Logging into a Unix system"*:

---

### **Logging into a Unix System**

- **In general:**
  - Done with a **username + password** pair.
  - **Multiple users can log in at the same time**.
  - One user can **have multiple sessions** open simultaneously.

- **Users are separated from each other:**
  - For example, each user has their own **"home" directory**.

- **You can use either a graphical or text-based interface:**
  - A terminal launched in a **graphical interface is equivalent** to a real, text-based terminal.

---

This explains the basics of Unix multi-user access, session management, and terminal usage.


Hereâ€™s the translated and summarized content of the slide titled **"Parancsok bevitele"** â€“ *"Entering Commands"*:

---

### **Entering Commands**

- **Commands are typed after the prompt.**
- The **prompt ends with `$`** (normal user) or **`#`** (root user).
- Entered commands can be edited using **arrow keys**, **backspace**, **delete**, etc.
- Use the **up/down arrows** to scroll through previously entered commands.
- Use **Ctrl + R** to **search past commands** by typing part of the command.
- The **`history`** command lists previously entered commands, each with a number.
  - `!12` â€“ Executes command number 12.
  - `history -c` â€“ Clears the command history.

---

This slide explains how to interact with the terminal command line efficiently, including editing and recalling commands.

Hereâ€™s the translated and summarized content of the slide titled **"EgyÃ©b hasznos billentyÅ±parancsok"** â€“ *"Other Useful Keyboard Shortcuts"*:

---

### **Other Useful Keyboard Shortcuts**

- **Ctrl + C**: Terminates the currently running program. *(May not always work.)*
- **Ctrl + L**: Clears the screen, but the command being edited remains.
- **Tab**: Attempts to autocomplete the command.
- **Double Tab**: If autocomplete isn't clear, pressing Tab again will list the possible options.

---

These shortcuts are essential for efficient work in the terminal.


Hereâ€™s the translated and summarized content of the slide titled **"A Unix fÃ¡jlrendszer"** â€“ *"The Unix Filesystem"*:

---

### **The Unix Filesystem**

- It uses a **tree structure** with a **single common root directory** (there are no drive letters like in Windows).
- **Everything is a file** in Unix. There are several file types:

#### File types:
- **Regular file** â€“ normal data file.
- **Directory** â€“ a special file that contains file listings.
- **Other special files:**
  - **Hard link** â€“ alternative name pointing to the same data.
  - **Soft link (symbolic link)** â€“ shortcut pointing to another file.
  - **Character and block devices** â€“ represent hardware devices.
  - **FIFO** â€“ a special file for named pipes (inter-process communication).

---

This slide highlights the unified, file-based approach of Unix systems, which treats almost all system elements as files.


Hereâ€™s the translated and summarized content of the slide titled **"ElÃ©rÃ©si utak"** â€“ *"File Paths"*:

---

### **File Paths**

- The **root directory is represented by `/`**.
- Subdirectories are also separated by the `/` symbol.

#### **Examples:**

- **Absolute paths** (start from the root `/`):
  - `/bin`
  - `/usr/bin/perl`
  - `/home/antiemes/proba/olvassel.txt`

- **Relative paths** (relative to the current directory):
  - `proba/olvassel.txt`

---

This slide explains how directory paths work in Unix-like systems, distinguishing between **absolute** and **relative** paths using the `/` separator.




Hereâ€™s the translated and summarized content of the slide titled **"SpeciÃ¡lis elÃ©rÃ©si utak"** â€“ *"Special File Paths"*:

---

### **Special File Paths**

- `.` (dot): Refers to the **current directory**
- `..` (double dot): Refers to the **parent directory** (one level up)
- `~` (tilde): Refers to the **current user's home directory**

#### **Examples:**
- `./elso.sh` â†’ the `elso.sh` file in the current directory
- `../doksi.txt` â†’ the `doksi.txt` file in the parent directory
- `../../kep/szep.jpg` â†’ the `szep.jpg` file in the `kep` directory two levels up

---

This slide helps you understand how to navigate and reference directories and files in relation to your current working directory in Unix-like systems.



Hereâ€™s the translated and summarized content of the slide titled **"MozgÃ¡s a kÃ¶nyvtÃ¡rak kÃ¶zÃ¶tt"** â€“ *"Navigating Between Directories"*:

---

### **Moving Between Directories**

- Use the `cd` (change directory) command:
  ```
  cd path_to_directory
  ```

#### **Examples:**

- `cd /` â†’ goes to the **root directory**
- `cd ..` â†’ moves **up one level**
- `cd /ez/az/amaz` â†’ navigates to `/ez/az/amaz` **from the root**
- `cd ez/az/amaz` â†’ navigates to `ez/az/amaz` **relative to the current directory**
- `cd ~/ez/az/amaz` â†’ navigates to `ez/az/amaz` **from your home directory**

---

This slide explains how to use the `cd` command with absolute and relative paths in Unix/Linux.

Hereâ€™s the translated and summarized content of the slide titled **"Az aktuÃ¡lis kÃ¶nyvtÃ¡r"** â€“ *"The Current Directory"*:

---

### **The Current Directory**

- You can check it using the **`pwd`** command (print working directory).
- The current directory usually appears in the **command prompt**.

#### **Example prompt:**
```
[antiemes] [Flow] [/mnt/proj/OS_new] [$]
```
- Here, `/mnt/proj/OS_new` is the **current working directory**.

---

This slide explains how to find out which directory you're currently in, using both the `pwd` command and the terminal prompt.

Hereâ€™s the translated and summarized content of the slide titled **"KÃ¶nyvtÃ¡rak tartalmÃ¡nak listÃ¡zÃ¡sa"** â€“ *"Listing Directory Contents"*:

---

### **Listing Directory Contents**

- Done using the **`ls` command**.
- The `ls` command accepts many **parameters** that control:
  - **What** to list â€“ using **paths**
  - **How** to list â€“ using **options (flags)**

- If you **donâ€™t give any parameters**, it simply lists the **current directory**.
- You can also specify **one or more paths** (file or directory names), and it will list those.

---

This slide introduces the `ls` command, which is essential for viewing files and directories, with flexibility through arguments and options.

Hereâ€™s the translated and summarized content of the slide titled **"Az ls parancs kapcsolÃ³i â€“ I."** â€“ *"Options for the `ls` Command â€“ I."*:

---

### **Useful `ls` Command Options**

- `-l` *(long)* â€“ long listing format, shows detailed info (permissions, size, date, etc.)
- `-a` *(all)* â€“ includes hidden entries (files starting with a dot)
- `-h` *(human)* â€“ human-readable file sizes (e.g., KB, MB instead of just bytes)
- `-1` â€“ displays output in a **single column**
- `-R` *(recursive)* â€“ lists directories and all their contents recursively
- `-d` *(directory)* â€“ lists the **directory itself**, not its contents

> Additionally, there are **many more possible options** to explore.

---

This slide helps you get more out of the `ls` command by adjusting how and what it displays.








Hereâ€™s the translated and summarized content of the slide titled **"Az ls parancs kapcsolÃ³i â€“ II."** â€“ *"Options for the `ls` Command â€“ II."*:

---

### **Combining `ls` Options**

- **Options can be combined**, for example:
  - `-a -l` â†’ long listing with hidden files
  - `-al` â†’ same as above, shorthand version
  - `-alh` â†’ same, but with human-readable file sizes

### **You can also specify one or more paths along with the options:**

- `ls -l /` â†’ gives a **long listing** of the root directory
- `ls -R /home/antiemes/stuff` â†’ **recursively lists** the specified directory

---

This slide explains how to **combine options** and **use them with paths** for more powerful usage of the `ls` command.

### **TL;DR â€“ `ls -l` Long Listing Format**

- Example output:
  ```
  total 16
  -rw-r--r-- 1 antiemes users 2650 Feb  6 16:45 BlinkAppC.nc
  -rw-r--r-- 1 antiemes users 2924 Feb  6 16:45 BlinkC.nc
  drwxr-xr-x 3 antiemes users   60 Feb  6 16:45 build
  -rw-r--r-- 1 antiemes users   42 Feb  6 16:45 Makefile
  -rw-r--r-- 1 antiemes users  678 Feb  6 16:45 README.txt
  ```

- `total 16`: total disk space used (in blocks)
- Each line after that contains **7 columns**, showing:
  1. File type & permissions
  2. Number of links
  3. Owner
  4. Group
  5. File size (in bytes)
  6. Last modified date & time
  7. File or directory name

This is how you interpret detailed file information using `ls -l`.

### **The 7 Columns of `ls -l` Output**

Each line of `ls -l` contains these 7 fields:

1. **Type and permissions** (e.g., `-rw-r--r--`) â€“ will be discussed later
2. **Link count** â€“ number of hard links to the file/directory
3. **Owner** â€“ the user who owns the file
4. **Group** â€“ the group that owns the file
5. **Size in bytes** â€“ can be changed to human-readable (`-h` option)
6. **Date** â€“ last modification time (default)
7. **Name** â€“ the filename or directory name

---

This slide breaks down the structure of a long listing in the terminal to understand each piece of information shown.


### **Entry Type (BejegyzÃ©s tÃ­pusa)**

- The **first character** in the `ls -l` output indicates the **type of file**, followed by three sets of **three characters** representing permissions.

---

### **File Types:**

| Symbol | Meaning                |
|--------|------------------------|
| `-`    | Regular file           |
| `d`    | Directory              |
| `l`    | Symbolic (soft) link   |
| `c`    | Character device       |
| `b`    | Block device           |
| `s`    | Socket                 |
| `p`    | FIFO (named pipe)      |

> `*` â€“ Listed for completeness, not commonly used in daily tasks.

---

This slide helps you interpret the first character in a long listing (`ls -l`) to identify file types in Unix/Linux.

### **Permissions (JogosultsÃ¡gok)**

---

- **Permissions are shown in 3 groups of 3 characters each:**
  - For **owner (u)**, **group (g)**, and **others (o)**

#### **Permission symbols:**
- `r` â€“ read permission
- `w` â€“ write permission
- `x` â€“ execute permission
- `-` â€“ permission **not granted**
- *(Other letters exist, but are not covered here.)*

---

- **Execute permission** has a special meaning for **directories**:  
  It means **you can enter (access) the directory**.

---

This slide explains how file and directory permissions work in Unix/Linux using symbolic notation.


### **Internal Documentation (BelsÅ‘ dokumentÃ¡ciÃ³)**

---

#### **`man` (manual) command:**
- Usage: `man [section] command_or_topic`
- The output is displayed with **`less`** (or `more`), which allows **scrolling** and **searching**.

#### **Other help options:**
- Most programs also support:
  - `-h`
  - `-help`
  - `--help`  
  These often display useful information about usage and options.

#### **Manual pages are also available online.**

---

### **Examples:**
- `man ls` â€“ help for the `ls` command  
- `man man` â€“ help for using the `man` command itself  
- `man 7 regex` â€“ documentation on **regular expressions** in section 7

---

This slide introduces built-in tools for accessing documentation directly from the command line.



### **Creating a Directory (`mkdir`)**

---

#### **Command syntax:**
```bash
mkdir path_to_directory
```

---

### **Explanation:**

- If the given path is **just one directory name**, it will be created in the **current directory**.

- If a **nested path** is specified (e.g., `a/b/c`), it will **only be created if the beginning parts already exist**.  
  - Use the `-p` option to **create all missing directories** in the path:
    ```bash
    mkdir -p a/b/c
    ```

- You can **create multiple directories at once** by listing them:
  ```bash
  mkdir dir1 dir2 dir3
  ```

---

This slide introduces `mkdir`, a basic but essential command for working with directories in Unix/Linux systems.



### **Creating Files Without Content (`touch`)**

---

#### **Command syntax:**
```bash
touch name1 [name2 [name3 ...]]
```

---

### **Key Points:**

- If the files **donâ€™t exist**, they are **created empty**.
- If **no path** is given, the file is created in the **current directory**; otherwise, itâ€™s placed at the specified location.
- If the file **already exists**, it is **not overwritten**, but its **last modified timestamp is updated**.

---

This command is useful for creating empty files quickly or updating timestamps on existing ones.


### **Copying Files (`cp`) â€“ Part I**

---

#### **Command syntax:**
```bash
cp [options] source target
```

---

### **Behavior Overview:**

- There are multiple usage cases, but the logic is similar:
  - **The source is copied to the target location**

---

### **Common Scenarios:**

1. **Source: existing file, Target: new (non-existent) file**  
   - The target file is created and gets the same content as the source.

2. **Source: existing file, Target: existing file**  
   - The target file is **overwritten** with the source fileâ€™s content.

3. **Source: existing file(s), Target: existing directory**  
   - The file(s) are **copied into the target directory**.
   - If a file already exists there, it will be **overwritten**.

---

You can also specify full paths. If none is given, the current directory is used by default.


### **Copying Files (`cp`) â€“ Part II**

---

### **Copying Directories**
- To copy directories, use the `-r` (or `--recursive`) option:
  - `-r` = recursive
  - Copies the **contents** of the directory as well

---

### **Using Wildcards (Shell Patterns) in Source Names**

- Wildcards can help match multiple files:
  - `*.txt` â†’ copies all files ending in `.txt`
  - `*ab*` â†’ copies files that **contain "ab"** in their names
  - `vala*` â†’ copies files that **start with "vala"**
  - `*a*a*` â†’ copies files that contain **two "a" letters**

> âš ï¸ Important note:  
> These patterns are **expanded by the shell** into a list of matching files/directories **before** `cp` runs. So `cp` just receives a list of items to copy â€“ just like if you listed them manually.

---

This slide expands on copying functionality and shows how to efficiently select multiple files using shell wildcards.


### **Displaying Text with `echo` â€“ Part I**

---

#### **Basic usage:**
```bash
echo text
```

- Example:  
  `echo szoveg` â†’ just prints the word `szoveg`

- Multiple words also work:  
  `echo ez tobb szavas` â†’ prints: `ez tobb szavas`

---

### **Spacing behavior:**

```bash
echo itt     sok     space     van
```
- Output: `itt sok space van` â†’ **extra spaces are collapsed**

---

### **Why?**
- `echo` treats each word as a **separate argument**.
- It prints all arguments separated by **a single space**.

---

### **Solution: Use quotes**
```bash
echo "itt     sok     space     van"
```
- The entire string is treated as **one argument**, so all spacing is preserved.

---

This slide explains how `echo` handles arguments and how to preserve formatting with quotation marks.



### **Displaying Text with `echo` â€“ Part II**

---

### **Line Ending and Escape Sequences**

- By default, `echo` **adds a newline** at the end of the output.
  - Use `-n` to **suppress the newline**.

- Use `-e` to **enable interpretation of escape sequences**, such as:
  - `\t` â†’ tab
  - `\n` â†’ newline

---

### **Examples:**

```bash
echo -e "Ezt\tszepen\ttabulalva\tirja\tki."
```
â†’ Outputs the words separated by tabs.

```bash
echo -e "Minden\nszot\nuj\nsorba\nteszunk."
```
â†’ Puts each word on a **new line**.

---

This slide shows how to control formatting and special characters in terminal output using `echo`.



### **Shell Patterns (Wildcards)**

---

#### **Using `*` in commands like `echo` or `cp`:**
- `echo *` does **not print an asterisk**, but a **list of files and directories** in the current folder.
- The **shell replaces** the `*` with all matching filenames before the command runs.
- This applies to **other commands** too, like `cp` â€“ they donâ€™t see the `*`, they get a **list of files**.

---

### **How to prevent expansion (escape `*`):**

To print an actual asterisk, you can escape it:

```bash
echo "*"
echo '*'
echo \*
```

These commands **print the literal `*`** instead of expanding it into file names.

---

This slide explains shell expansion behavior and how to escape wildcard characters when needed.




Hereâ€™s a **TL;DR** summary of the slide titled **"TÃ¶rlÃ©s (rm)"** (Deletion with `rm` command):

---

### `rm` [options] file_and_directory_list
- Comes from the word **"remove"**.
- Paths can be **absolute** or **relative**. Defaults to the current directory.
- **Shell patterns** (wildcards) are allowed.
- **Directories** can be deleted with the `-r` (recursive) option â€” this deletes the directory and all its contents.
- For **read-only files**, it asks for confirmation; otherwise, it deletes without prompting.
  - `-f`: **never asks**, force deletion.
  - `-i`: **always asks** before deleting.

---

Let me know if you want a quick command reference or example usage too!

Here's a TL;DR translation and summary of the slide content:

---

### ğŸ“ Deleting a Directory (`rmdir`)

- **Syntax**: `rmdir directory [directory2 [directory3 â€¦]]`
- **Important Notes**:
  - Only deletes **empty** directories.
  - Supports **relative** or **absolute** paths, as well as **shell patterns**.
    - Example: `rmdir *` deletes all **empty directories** in the current location, leaving others untouched.

---

Let me know if you want a comparison with `rm -r` or examples in a script.




Here's a TL;DR summary and translation of the slide:

---

### ğŸ”„ Rename or Move (`mv`)

#### `mv source_file target_file`
- If the **source and target** are in the **same directory**, it **renames** the file.
- If they are in **different directories**, it **moves** the file.
- If the **target file exists**, it will be **overwritten**.

#### `mv source_files_and_dirs target_directory`
- Moves the listed **files and directories** into the **target directory**.
- **Shell patterns** can also be used here (e.g. `mv *.txt backup/`).

---

Let me know if you want command line examples or common use cases!


Here's a TL;DR summary and translation of the slide:

---

### ğŸ“„ Displaying File Content (`cat`)

#### `cat [file1 [file2 [file3 â€¦ ]]]`
- Name comes from **"concatenate"** (allegedly).
- Outputs the **contents of files in sequence**.
- Even this simple command has **many options** (e.g., it can **number lines**).
- Without parameters, it reads input from **standard input (stdin)**.
  - Press **Ctrl+D** to signal the end of input.

---

Let me know if you want examples of `cat` with options like `-n`, `-A`, or redirection.


Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ“– Paginated Content Display (`less`, `more`)

#### `less file`
- Like `man`, lets you **scroll up/down**, **search**, etc.
- The `man` command actually **uses `less`** internally.

#### `more file`
- Similar to `less`.
- A bit **more limited** (the slide jokes: "a bit dumber").

---

Let me know if you want a quick keybinding cheat sheet for `less` or when to use `more` over `less`.


Here's a TL;DR summary and translation of the slide:

---

### ğŸ”€ Output Redirection

#### â¤ `>` Redirect to file
- Most programs print to the screen â€” you can redirect this to a **file** with `>`.
- Example:
  - `ls -l > file`
  - `ls -R > file`  
  â†’ Output goes into the file instead of the screen.
- âš ï¸ If the file already exists, it will be **overwritten**!

#### â¤ `>>` Append to file
- Example:  
  `cat a*txt >> asok`  
  â†’ Appends all files starting with "a" and ending in `.txt` to the **`asok`** file.

#### â¤ `cat > program.sh`
- Allows you to **type directly** into the file.
- You can also **paste content** from clipboard â€” very handy!

---

Let me know if youâ€™d like quick practice tasks with redirection and appending.

Hereâ€™s a TL;DR summary and translation of the slide:

---

### â¬…ï¸ Input Redirection

- Many programs expect **input from the keyboard**.
- We can redirect **standard input** so the program reads from a **file** instead.
- Syntax:  
  `program < file`
- Useful when **testing our own programs**.

âœ… Example:  
`./example < input.txt`

---

Let me know if you want to combine this with output redirection (e.g., `program < input.txt > output.txt`).

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ”— Linking Files â€“ Part I: **Soft Link (Symbolic Link)**

- A **special file** that contains the **path** to another file.
- Using this link is usually equivalent to referencing the original file/directory.  
  â†’ **Except** for operations like **rename** or **delete**.
- **Create with**:  
  `ln -s existing_file [target_dir or target_file]`
  - If target is a **file name** â†’ link is created with that name.
  - If target is a **directory** â†’ link is created in that directory using the original name.
- âš ï¸ If the **original file is deleted**, the **link becomes broken** (content is lost).

---

Let me know if youâ€™d like a demo comparing soft and hard links!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ”— Linking Files â€“ Part II: **Hard Link**

- Creates **another filename** pointing to the **same file content**.
- **Command**:  
  `ln existing_file new_file`
- Deleting one does **not delete** the actual data â€” it remains as long as **one link exists**.
- The system uses a **link counter** to track how many links reference the same content.
- ğŸ”’ Restrictions:
  - Can only be created **within the same filesystem**.
  - Cannot be created for **directories**.

---

Let me know if you want a table comparing hard vs soft links side by side.

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Modifying Permissions â€“ Part I (`chmod`)

#### Syntax:
```bash
chmod modification file1 [file2 â€¦]
```

#### Format of modification:
```bash
who [+|-] what
```

**Who:**
- `u` â€“ user (owner)
- `g` â€“ group
- `o` â€“ others
- `a` â€“ all

**What:**
- `r` â€“ read permission
- `w` â€“ write permission
- `x` â€“ execute/access permission

**Operators:**
- `+` â€“ add permission
- `-` â€“ remove permission

âœ… Example:  
`chmod u+x script.sh` â†’ gives the owner execute permission on `script.sh`

---

Want help with symbolic vs numeric modes or examples with directories?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Modifying Permissions â€“ Part II (`chmod` continued)

#### âœ… Examples (symbolic mode):
- `u+x` â€“ Give the **owner** execute permission
- `ug+w` â€“ Give the **owner and group** write permission
- `a+x` â€“ Give **everyone** execute permission
- `go-rwx` â€“ Remove **all permissions** from **group and others**, keep ownerâ€™s

---

### ğŸ§® Setting Permissions Numerically (octal mode):
- Uses **3-digit octal** numbers:  
  `[owner][group][others]`
- Values:  
  - `r = 4`, `w = 2`, `x = 1` â†’ summed per group

#### ğŸ›  Examples:
- `chmod 640 doksi.txt`  
  â†’ Owner: read/write, Group: read, Others: none
- `chmod 777 pelda.sh`  
  â†’ **Everyone can do everything**

---

Let me know if you want a quick permissions cheat sheet or a practice task!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ‘¤ Changing Ownership

#### `chown new_owner file1 [file2 â€¦]`
- Changes the **owner** of the files to `new_owner`.

#### `chown new_owner:new_group file1 [file2 â€¦]`
- Changes both the **owner** and the **group**.

#### `chgrp new_group file1 [file2 â€¦]`
- Changes just the **group**.

ğŸ” Use `-R` for **recursive** changes â€” it will apply to all subdirectories and files too.

âš ï¸ **Admin (root) privileges** are required to perform these operations.

---

Let me know if you want a visual breakdown of ownership and permission fields in `ls -l` output!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ“„ File Start and End: `head` & `tail`

#### `head [-n number] file1 [file2 â€¦]`
- Prints the **first `number` lines** of the file.
- If not specified, **defaults to 10 lines**.
- Shows the file name too (can be hidden with `-q`).

#### `tail [-n number] file1 [file2 â€¦]`
- Same as `head`, but prints the **last `number` lines**.
- Supports shell patterns as well.

#### ğŸ§ª Examples:
- `head -n 8 leiras.txt` â†’ Displays the **first 8 lines** of `leiras.txt`
- `tail readme` â†’ Displays the **last 10 lines** of `readme`

â„¹ï¸ If no file is specified, input is read from **standard input** (keyboard, pipe, etc.)

---

Want examples with live log monitoring using `tail -f`?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Pipe â€“ Part I

- Programs that **write to standard output** and those that **read from standard input** can be **connected using a pipe (`|`)**.

#### ğŸ§ª Examples:
- `ls -l | tail -n 5`  
  â†’ Shows the **last 5 lines** of the `ls -l` output.
  
- `cat olvassel.txt | head -n 5`  
  â†’ Displays the **first 5 lines** of `olvassel.txt`.

ğŸ“ Note:
- This is **almost** the same as `head -n 5 readme.txt`, but not exactly!
- When using a pipe, the receiving command (like `head`) does **not know the original file name** â€” only the data.  
  â†’ Thatâ€™s why it **canâ€™t print the file name** when piped.

---

Want to continue to part II or see how to chain multiple pipes?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Pipe â€“ Part II

You can **chain multiple commands** using pipes:

#### ğŸ§ª Examples:

- `cat pelda.txt | head -n 20 | tail -n 1`  
  â†’ Takes the **first 20 lines** of `pelda.txt`, then selects the **last line** from that.  
  âœ… **Result:** line 20 of `pelda.txt`

- `ls -l | head -n 6 | tail -n 1`  
  â†’ From the `ls -l` output, grabs the **6th line**.

---

ğŸ“Œ Piping is powerful for extracting precise parts of command outputs. Want more complex examples using `grep`, `awk`, or `cut`?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ”¢ Lines, Words, Characters Count (`wc`)

- `wc` = **word count**, but it also counts **lines** and **characters**.

#### ğŸ§© Options:
- `-l` â†’ line count
- `-w` â†’ word count
- `-c` â†’ character count

âœ… You can **combine options**, e.g.:
- `wc -wl file.txt` â†’ counts **words and lines**

ğŸ’¡ **Default behavior**: prints **all three** (lines, words, characters).

---

Want a quick demo on piping output into `wc`, like `cat file | wc -l`?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ“Š `wc` â€“ Part II

#### ğŸ§© Modes of operation:

âœ… **Via Pipe**:
- `ls -1 | wc -l` â†’ counts files/directories listed by `ls`
- `cat pelda.txt | wc -w` â†’ counts **words** in `pelda.txt`
- In piped mode, `wc` **only shows the count**, **not the file name**.

âœ… **Single file as argument**:
- `wc -c pelda.txt` â†’ counts **characters** in `pelda.txt`
- Output includes the **count** and the **file name**.

âœ… **Multiple files**:
- Lists counts **per file**, and a **total** at the end.
- Works with **lines, words, characters**, etc.
  
âœ… **Shell wildcards** (e.g. `*.txt`) work here too.

---

Let me know if you'd like some combined examples with `find`, `xargs`, or `grep`.

Hereâ€™s a TL;DR summary and translation of the slide:

---

### âœ‚ï¸ Cutting Fields (`cut`) â€“ Part I

You can **cut text** either **by character** or **by field**.

#### ğŸ”  By Character:
- `cut -c start-end`  
  â†’ returns characters in the range `[start, end]` from each line.
- `cut -c num1,num2,num3`  
  â†’ returns specific character positions (e.g. 1st, 3rd, 5th).
- You can **combine** positions and ranges:  
  `cut -c 1,4-7,9`  
  â†’ one specific, a range, and another specific character.

#### ğŸ§ª Example:
- `ls -l | cut -c 2-10`  
  â†’ Extracts the **permissions** field from `ls -l` output.

---

Would you like to see Part II for field-based cutting using delimiters (like `-d` and `-f`)?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### âœ‚ï¸ Cutting Fields (`cut`) â€“ Part II (By Field)

#### ğŸ“Œ Field-based cutting:

- `cut -d: -f 1,5 /etc/passwd`  
  â†’ Cuts **fields 1 and 5** from `/etc/passwd` using **colon (`:`)** as the **delimiter**.

- `cut -f 1,3 lista_nagy.txt`  
  â†’ Cuts **fields 1 and 3** from `lista_nagy.txt`, where fields are separated by **tabs** (default delimiter).

â„¹ï¸ If no delimiter is specified, `cut` assumes **tabs** by default.

---

Let me know if you'd like a comparison with `awk` or `csvkit` for more complex field processing!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ”¢ Sorting (`sort`)

#### ğŸ“š Basic usage:
- `cat nevek.txt | sort` â†’ sorts lines **alphabetically**
- `sort nevek.txt` â†’ same as above, no pipe needed

#### ğŸ”‘ Sort by specific field:
- `ls -l | sort -k 3` â†’ sorts by the **3rd field** (e.g. owner)

#### ğŸ”¢ Numerical sorting:
- `ls -l | sort -n -k 5` â†’ sorts by **file size**
- `ls -l | sort -n -k 5 -r` â†’ sorts by size in **reverse order**

#### ğŸ§  More complex example:
- `ls -l | sort -k 5 -n | tail -n 1`  
  â†’ shows the **largest file** in the listing

---

Let me know if you want examples for sorting CSV files or combining `sort` with `uniq`.

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Removing Duplicate Lines (`uniq`)

- If **identical lines appear consecutively**, `uniq` will keep **only one**.
- ğŸ”„ **Sorting first** is useful, since `uniq` only removes **adjacent** duplicates.

#### ğŸ§ª Example:
```bash
cat nevek.txt | sort | uniq
```

âœ… Equivalent to:
```bash
sort -u nevek.txt
```

> `sort -u` = sort **and** remove duplicates in one step.

---

Let me know if you'd like to combine this with `wc`, `cut`, or `grep` for data cleanup!


Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Filtering (`grep`) â€“ Part I

- `grep` returns lines that **match a regular expression**.  
  *(Regex details will come on a later slide.)*

- You can check if a pattern **exists** in input even **without printing matches**.

- Searches are **case-sensitive** by default â€” use `-i` to make it **case-insensitive**.

#### ğŸ§ª Usage:

**With a pipe:**
```bash
command | grep [options] pattern
```

**With a file:**
```bash
grep [options] pattern file
```

---

Let me know if you'd like help with common `grep` options like `-v`, `-r`, or `-n`!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Filtering (`grep`) â€“ Part II  
#### ğŸ§¬ Syntax Types (Regular Expressions)

#### ğŸ“˜ Basic Regex Syntax
- Characters like `?`, `+`, `{`, `|`, `(`, `)` work as **normal characters** unless escaped.
- Use **`\?`, `\+`** etc. to enable their **meta** behavior.

#### ğŸ“— Extended Regex Syntax
- Offers **more power** and convenience.
- Meta characters like `?`, `+`, `{` work **without** backslashes.
- Use with `grep -E` or `egrep`.

#### ğŸ“™ Perl Regex Syntax
- **Even more features**, e.g. `\w`, `\d`, `\s`.
- Use `grep -P` in **modern implementations**.

---

Want examples showing the difference between basic and extended syntax in practice?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Filtering (`grep`) â€“ Part III

#### ğŸ§° Useful Options:

- `-v` â†’ **Invert match**: return lines **not** matching the pattern  
- `-e pattern` â†’ Use this if your pattern **starts with a dash** (`-`), or to **combine multiple patterns**
- `-A num` â†’ Show **num lines after** the matching line  
- `-B num` â†’ Show **num lines before** the matching line  
- `-q` â†’ **Quiet mode**: no output, but sets exit code (âœ… useful in scripts)

---

### ğŸ“ Filename Display:

- When using pipes or a **single file**, grep **doesnâ€™t show the filename**.
- With **multiple files**, grep shows the **filename before each match**.
- Use `-H` to **force show** filenames, even with one file.  
- Use `-h` to **suppress** filenames in multi-file input.

---

Let me know if you want a visual cheat sheet or grep + regex exercises!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### âš™ï¸ Processes and Jobs â€“ Part I

#### ğŸ“ The `/proc` virtual filesystem:

- Located at `/proc`, it's a **virtual filesystem** used to **interact with processes**.

- Contains **directories named by PID** (Process ID), each representing a running process.

- Inside each process's folder, you can find information like:
  - ğŸ”“ Open files
  - ğŸ“Š Memory and CPU time stats
  - ğŸ‘¤ Owner
  - ğŸ§  Other state information

- Also contains **system-wide** directories and files for querying or configuring kernel settings.

---

Let me know if youâ€™d like a tour of useful files like `/proc/cpuinfo`, `/proc/meminfo`, or `/proc/[pid]/status`.


Hereâ€™s a TL;DR summary and translation of the slide:

---

### âš™ï¸ Processes and Jobs â€“ Part II

#### ğŸ“‹ `ps` command â€” list and get info about processes

- Works based on the `/proc` virtual filesystem.

#### ğŸ”§ Common options:
- `aux`  
  â†’ Shows **all processes** with **full details**
- `w`, `ww`  
  â†’ Enables **wide output** (shows full command with arguments)
- `f`  
  â†’ Displays a **tree-like structure** (parent-child relationships)

#### ğŸ“Š The process list includes:
- Owner  
- PID  
- CPU and memory usage  
- Status  
- Name  
- And other details

---

Let me know if youâ€™d like a comparison with `top`, `htop`, or `pstree`.
 

 Hereâ€™s a TL;DR summary and translation of the slide:

---

### âš™ï¸ Processes and Jobs â€“ Part III  
#### ğŸ”ª `kill` Command

- **Send signals to processes** using:
  ```bash
  kill [-signal_number | -signal_name] PID
  ```

#### ğŸ“Œ Common signals:
- `15 (TERM)` â€“ Politely **asks the process to terminate** (default, can be ignored)
- `9 (KILL)` â€“ **Forcefully stops** the process (canâ€™t be caught or ignored)
- `17, 19, 23 (STOP)` â€“ **Pauses** the process
- `19, 18, 25 (CONT)` â€“ **Resumes** the process

---

#### ğŸ”« `killall` Command:
- Syntax:
  ```bash
  killall [-signal_number | -signal_name] process_name
  ```
- Sends the signal to **all processes matching the given name** (instead of using PIDs)

---

Let me know if you want a cheat sheet of all common signals (`kill -l`) or signal-handling in C!


Hereâ€™s a TL;DR summary and translation of the slide:

---

### âš™ï¸ Processes and Jobs â€“ Part IV  
#### ğŸ§  Managing jobs in the terminal

You can run **multiple programs as jobs** in the terminal.  
At most, **one job is in the foreground** at any time.

#### ğŸ§° Useful commands:

- `jobs`  
  â†’ Lists all **current jobs**

- `bg [number]`  
  â†’ Puts the **current or specified job** in the **background**

- `fg [number]`  
  â†’ Brings the **current or specified job** to the **foreground**

- `kill %number`  
  â†’ Sends a signal to a **job** using the **job ID** (not PID), prefixed with `%`

---

Let me know if you want to explore job control shortcuts like `Ctrl+Z`, `&`, or use cases!


Hereâ€™s a TL;DR summary and translation of the slide:

---

### âš™ï¸ Processes and Jobs â€“ Part V

#### â–¶ï¸ Running a program in the background:
- Example:
  ```bash
  xterm &
  ```
  The `&` runs the command **in the background**.

#### ğŸ›‘ Pausing an active process:
- Press **`Ctrl+Z`** to **suspend** the current foreground process.

Then you can:
- Use `fg` to bring it **back to foreground**
- Use `bg` to resume it **in the background**

âš ï¸ Some programs **disable this feature** and cannot be suspended this way.

---

Let me know if you want a quick summary of job states or signals that affect them!



Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Searching (`find`) â€“ Part I

#### ğŸ“ Searching for files and directories based on:
- **Name** (can use shell patterns or regular expressions)
- **Type** (e.g. file, directory)
- **Size** and other attributes (e.g. permissions, timestamps)

#### ğŸ” What to do with the results:
- Simply **list** them
- Or **execute a command** on each of them

---

Let me know if you'd like some `find` examples like:
- by name: `find . -name "*.txt"`
- by size: `find . -size +1M`
- with action: `find . -type f -exec rm {} \;`


Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Searching (`find`) â€“ Part II

#### ğŸ§¾ Syntax:
```bash
find directory [options] [expression]
```

#### ğŸ“ Directory:
- The directory where the search **starts**
- It appears at the **start of the result paths** (except for `~`)

#### ğŸ”§ Useful options:

- `-name`, `-iname` â†’ Match by name (`-iname` is **case-insensitive**)  
- `-regex`, `-iregex` â†’ Match using **regular expressions** (case-sensitive or not)  
- `-type f`, `-type d` â†’ Filter by type: file (`f`) or directory (`d`)  
- `-size` â†’ Match by **file size**  
- `-exec` â†’ Execute a **command** on each match

---

Let me know if you want working examples with `-exec`, `-mtime`, or cleanup scripts using `find`!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Searching (`find`) â€“ Part III  
#### ğŸ“‚ Paths and Types

- `find`  
  â†’ Without parameters, it searches in the **current directory**, including files and folders.

- `find .`  
  â†’ Equivalent to the above, explicitly searches `.` (current directory).

- `find proba`  
  â†’ Searches in the **`proba`** directory.

- `find proba -type f`  
  â†’ Finds only **regular files** in `proba`.

- `find proba -type d`  
  â†’ Finds only **directories** in `proba`.

---

Let me know if you want to see how to use `find` with `-name`, `-exec`, or time-based filters like `-mtime`!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Searching (`find`) â€“ Part IV  
#### ğŸš Shell Patterns (Globbing)

- `find -name "*.txt"`  
  â†’ Finds files ending in `.txt`. *(Always quote the pattern!)*

- `find -name "*.sh" -type f`  
  â†’ Finds **regular files** ending in `.sh`

- `find -name "fe*t" -type f`  
  â†’ Finds files **starting with `fe` and ending in `t`**

- `find -name "*a*m*" -type f`  
  â†’ Finds files containing **`a` followed by `m`** in that order

- `find -name "*[xyz]*" -type f`  
  â†’ Finds files whose name contains **x, y, or z**

---

Let me know if you'd like to combine this with `-exec`, or compare with regex-based `-regex` patterns.

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Searching (`find`) â€“ Part V  
#### âš™ï¸ Executing commands on results (`-exec`)

You can do more than list files â€” you can **run commands** on them:

#### ğŸ”§ Syntax:
```bash
find [other options] -exec command "{}" \;
```

- The command after `-exec` is **executed for each match**
- `{}` is **replaced by the current file or directory**
- `\;` **ends** the `-exec` argument list (important!)

âœ… After `-exec`, you can use most commands you've already learned â€” and they will make sense!

---

Let me know if you want practical examples, like deleting files (`rm`), moving them, or using `-exec ... +` for better performance.


Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Searching (`find`) â€“ Part VI  
#### ğŸ§ª Examples of using `-exec`

- `-exec ls -l "{}" \;`  
  â†’ Lists all found items in **long format**

- `-exec ls -ld "{}" \;`  
  â†’ Same, but for **directories**, doesn't list contents

- `-exec head -n 5 "{}" \;`  
  â†’ Displays **first 5 lines** of each found file

- `-exec tail -n 8 "{}" \;`  
  â†’ Displays **last 8 lines** of each found file

- `-exec cat "{}" \;`  
  â†’ Prints the **entire contents** of each found file

- `-exec wc -l "{}" \;`  
  â†’ Counts **lines per file**, shows filename  
  *(You can also use `-w` for words, `-c` for characters)*

---

Let me know if you want to try chaining `find` with `xargs` for efficiency, or replacing `-exec` with `+` to batch files!


Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Searching (`find`) â€“ Part VII  
#### ğŸ§ª More examples using `-exec`

- `-exec grep pattern "{}" \;`  
  â†’ Prints lines **matching the pattern** from each found file

- `-exec rm "{}" \;`  
  â†’ **Deletes** each found file

- `-exec cp "{}" directory/ \;`  
  â†’ **Copies** found files into a **directory**

- `-exec sort "{}" \;`  
  â†’ **Prints contents** of each found file, **sorted**

- `-exec mv "{}" "{}".old \;`  
  â†’ **Renames** each file by appending `.old`  
  (`{}` can be used multiple times)

- `-exec chmod a+x "{}" \;`  
  â†’ **Adds execute permission** for everyone

---

Let me know if you'd like help switching to `-exec ... +` for better performance or using `xargs` as an alternative.

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Searching (`find`) â€“ Part VIII  
#### ğŸ”— Using `pipe` after `find` for further processing

- `find ... | wc -l`  
  â†’ **Counts** how many items `find` returns

- `find ... -exec cat "{}" \; | wc -l`  
  â†’ **Counts lines** across all matching files

- `find ... -exec cat "{}" \; | sort`  
  â†’ Sorts **all lines** from the matching files

- `find ... -exec cat "{}" \; | grep pattern | sort`  
  â†’ Filters lines matching **pattern**, then sorts them

- `find ... -exec ls -l "{}" \; | awk '{print $9 "\t" $5}' | sort -k 2 -n`  
  â†’ Finds the **longest file** (sorts by file size)

- `find ... -exec head -n 1 "{}" \; | sort`  
  â†’ Sorts files by their **first line**

- `find ... -exec wc -l "{}" \; | sort -n`  
  â†’ Sorts files by **line count**

---

Let me know if you want breakdowns of these examples or help adapting them for your own data!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Searching (`find`) â€“ Part IX  
#### âš¡ Improving performance with `xargs`

- Using `-exec` runs the command **once per file**, which can be slow.
- `xargs` builds a **single command** from all results â€” much faster!

---

### ğŸ—‘ï¸ Deleting all found files:

- `find ... -exec rm "{}" \;`  
  â†’ Runs `rm` **for every match** (slow)

- `find ... | xargs rm`  
  â†’ Runs `rm` **once**, passing all files (faster)

- `find ... -print0 | xargs -0 rm`  
  â†’ Safe version that handles **filenames with spaces or special characters**

---

Let me know if youâ€™d like more `xargs` tricks or a comparison with `-exec ... +`.


Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Searching (`find`) â€“ Part X  
#### ğŸ”— Combining `-exec` with `pipe`

- `find ... -exec head -n 3 "{}" | tail -n 1 \;`  
  â†’ **Doesn't work** as expected â€” `tail` isnâ€™t run per file.

- âœ… Correct approach:
  ```bash
  find ... -exec sh -c 'head -n 3 "{}" | tail -n 1' \;
  ```
  - This starts a **subshell** (`sh`) using `-c`
  - The subshell runs the full **piped command**
  - `{}` is passed into the subshell, so you can use `|` and other shell features

---

Let me know if you want to generalize this for more complex logic in `-exec sh -c '...'` or learn safer quoting tricks!


Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Searching (`find`) â€“ Part XI  
#### ğŸ“„ Searching by **file content**

```bash
find . -name "*.conf" -exec sh -c 'if grep -q pattern "{}"; then echo "{}"; fi' \;
```

- This command **finds `.conf` files** and **checks their content** with `grep -q`
- `-q` â†’ quiet mode: doesnâ€™t print matches, just returns **success/failure**
- If `grep` finds a match, the filename (`{}`) is printed

> Useful when you only want to list files **containing specific text**

---

Let me know if you want to extend this to do something more than just `echo` (e.g., copy, move, modify).

# Shell scripts

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ“œ Overview of Shell Scripts

- A **shell script** is written in the **command interpreter's language** (e.g., Bash).
- Useful for creating **short, compact solutions** for many tasks.

---

### ğŸ§¾ Key Points:

- Shell scripts are **plain text files** that contain **commands**.
- They do **not need to be compiled** â€” the shell directly **interprets the source code**.
- The main difference from regular text files:  
  â¤ They must have **execute permission** (`chmod`).
- File extension is **usually `.sh`**, but thatâ€™s **just a convention**, not a requirement.

---

Let me know if you want to dive into writing your first script!


Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ“ General Format and Execution of Shell Scripts

#### ğŸ”¹ Start of a shell script:
- First line:  
  ```bash
  #!/bin/bash
  ```
  â†’ This is the **shebang**, telling the system which **shell** should interpret the script.

- It launches a **new shell process** to execute the script.

---

#### ğŸ”¸ Running the script:
You start the script by typing its **full or relative path**:

```bash
./elso.sh
```

or

```bash
/home/antiemes/proba/elso.sh
```

âœ… Donâ€™t forget the script must have **execution permissions** (`chmod +x elso.sh`).

---

Want help writing your first shell script with variables and loops?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ› ï¸ Creating a Shell Script

#### ğŸ“¥ Using `cat` with redirection:
```bash
cat > elso.sh
```
- Everything you type will be saved to `elso.sh`
- Press `Ctrl+D` to **end input**
- Useful when you have code in the clipboard you want to **paste into a file**

---

#### âœï¸ Using a text editor:
- With **Midnight Commanderâ€™s editor**:  
  ```bash
  mcedit elso.sh
  ```

- With **Vi/Vim**:  
  ```bash
  vi elso.sh
  ```

---

Let me know if you want to set up syntax highlighting or create a minimal script template!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ“ `mcedit` â€” Simple Text Editor

An easy-to-use text editor, part of **Midnight Commander**.

#### ğŸ”‘ Key features:

- ğŸ’¾ **Save**: `F2` (or `Esc 2`)
- ğŸšª **Exit**: `F10` (or `Esc 0`)
- â†©ï¸ **Undo**: `Ctrl + U`

#### ğŸ“‹ Copying text:
1. Go to the **start** of the section â†’ press `F3`  
2. Go to the **end** of the section â†’ press `F3` again  
3. To **paste** after the cursor â†’ press `F5`  
4. To **delete** selected text â†’ press `F8`  
   - (If nothing is selected, it deletes the current line)

---

Let me know if youâ€™d like a cheat sheet or a comparison with `nano`, `vim`, or `gedit`.

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ”„ Sourcing in Shell

#### ğŸŸ¢ A script can be run as if you typed its content directly:

```bash
source elso.sh
```

or:

```bash
. ./elso.sh
```

â¡ï¸ These do **not launch a new shell** (no new process), unlike:

```bash
./elso.sh
/home/antiemes/proba/elso.sh
```

---

### âš ï¸ Key Difference:
When **sourced**, the script runs in the **current shell** â†’  
**Variables and settings persist** after it runs!

Useful when you want to **export environment variables** or **define functions** globally.

Let me know if you'd like to see a demo script using `source` with environment setup!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ§® Variables â€“ Part I

- Just like in most programming languages, **you can use variables** in shell scripts.
- Variables are **untyped** â†’ they can hold **text or numbers**.
- No need to **declare** them before use.

âœ… You can simply assign a variable like this:
```bash
name="Alice"
count=42
```

Let me know if you'd like to see how to use variables in strings, with arithmetic, or inside conditionals!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ§® Variables â€“ Part II  
#### ğŸ”¹ Assigning values

```bash
valtozo=ertek        # Basic syntax  
szoveg=hello         # Simple value  
fnev=valami.txt      # Filename stored in a variable  
sz1="Text with space"   # Double quotes allow variable expansion  
sz2='Literal text'      # Single quotes are fully literal
```

---

### ğŸ“ Quoting rules:
- **Single quotes `' '`** â†’ Everything is passed **literally**  
  â†’ No variable expansion, no command substitution

- **Double quotes `" "`** â†’ Mostly literal, **but allows variables** and some expansions  
  â†’ More flexible, often safer than no quotes at all

---

Let me know if youâ€™d like examples showing how quotes affect variable expansion or command substitution!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ§® Variables â€“ Part III  
#### ğŸ“¥ Accessing variable values

- Use the **`$variable`** format to get the value:
  ```bash
  echo $szoveg
  cat $fnev
  ```

- If the variable is followed by **text without spacing**, use curly braces:
  ```bash
  echo $szoveghello      # looks for variable named `szoveghello`
  echo ${szoveg}hello    # expands `szoveg`, then adds `hello`
  ```

âœ… `${var}` avoids ambiguity when variables are **next to other text**.

---

Let me know if you want a quick demo script using variables in filenames or paths!


Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ§® Variables â€“ Part IV  
#### ğŸ” Substitution & Quoting

- The expression `$valtozo` is **replaced with the variableâ€™s value**.
- It works in most cases, but itâ€™s **recommended** to wrap it in **double quotes**:
  ```bash
  "$valtozo"
  ```
- Why?
  - Double quotes **expand the variable**
  - But everything else inside the quotes is treated **literally**
  - This prevents bugs with spaces, special characters, etc.

âœ… **Always use `"$var"` instead of `$var`** unless you have a reason not to.

---

Let me know if you want examples of when unquoted variables can cause problems!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ§® Variables â€“ Part V  
#### ğŸ”— Concatenating variables and strings

You can **combine** multiple variables or strings easily:

```bash
echo $val1$val2$val3        # Basic case
echo "$val1$val2$val3"      # Safer: handles special characters
```

But be careful with **variable boundaries**:

```bash
echo ${val1}text$val3       # Prevents confusion (e.g., text isn't part of val1)
```

You can also **separate variables and strings** with quotes:

```bash
echo "$val1"text"$val3"     # All values are clear and safe
echo "${val1}text${val3}"   # Best practice: no ambiguity, safe expansion
```

âœ… Use **quotes and braces** to avoid accidental merging or misinterpretation.

---

Let me know if you want to see an example with spaces or special characters inside variables!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ§¾ Command-line Arguments â€“ I  

- Just like built-in commands, your **own scripts** can accept arguments.
- **Passing arguments** to a script:
  ```bash
  ./elso.sh first_argument second_argument
  ```

- Inside the script:
  - `$1` â†’ first argument  
  - `$2` â†’ second argument  
  - and so on...

- ğŸ’¡ Always use **`"$1"` instead of $1** â€“ this avoids issues with spaces and special characters.

---

Let me know if youâ€™d like to see a script example that uses parameters like these!

Hereâ€™s a quick summary and translation of this slide:

---

### ğŸ§¾ Command-line Arguments â€“ II

#### âœ… Using `$1`, `$2`, etc. in practice:

- **Print the first argument**  
  ```bash
  echo "$1"
  ```

- **Write the first argumentâ€™s content into a file named in the second argument**  
  ```bash
  echo "$1" > "$2"
  ```

- **Copy the file named in the first argument to the directory named in the second**  
  ```bash
  cp "$1" "$2"
  ```

ğŸ’¡ Use quotes (`"$1"` and `"$2"`) to handle spaces or special characters safely!

---

Want to try writing a small script that does these automatically?

Hereâ€™s a summary and translation of the slide titled **"Parancssori argumentumok â€“ III."** (Command-line arguments â€“ III):

---

### ğŸ› ï¸ Task:
You are given 5 parameters. The goal is to:

1. **Search** for files in the directory given in the **1st parameter**,
2. That **match the pattern** from the **2nd parameter**,
3. **Filter the contents** of those files for lines that match the pattern from the **3rd parameter**,
4. And **redirect the results** into a file named as in the **5th parameter**, located in the directory given in the **4th parameter**.

---

### âœ… Solution (Command):
```bash
find "$1" -type f -name "$2" -exec grep "$3" "{}" \; > "$4/$5"
```

#### ğŸ” Explanation:
- `find "$1"`: Search in the directory from argument 1.
- `-type f -name "$2"`: Look for regular files matching the pattern from argument 2.
- `-exec grep "$3" "{}"`: Run `grep` with pattern from argument 3 on each found file.
- `> "$4/$5"`: Write all the filtered output into the target file.

---

Want me to break this into a reusable shell script for you?

Hereâ€™s the translated breakdown of **"Parancssori argumentumok â€“ IV."** (Command-line arguments â€“ IV):

---

### ğŸ› ï¸ Task:

1. **Print one specific line** from a file:
   - From the file given in the **1st parameter**, print the line number specified in the **2nd parameter** to the screen.

2. **Count matching lines** and **append result to a file**:
   - In the directory given by the **3rd parameter**, count how many lines across all `.txt` files contain the **word given in the 4th parameter**.
   - Append this count to the file specified by the **5th parameter**.

---

### âœ… Solution:

```bash
head -n "$2" "$1" | tail -n 1
```

> This prints the **$2-th line** from file **$1**.

```bash
find "$3" -type f -name "*.txt" -exec grep "$4" "{}" \; | wc -l >> "$5"
```

> This:
- Searches for `.txt` files in **$3**,
- Greps for **$4** in them,
- Counts the matching lines with `wc -l`,
- And appends the result to **$5**.

---

Want this turned into a reusable script?


Hereâ€™s the English translation of the slide **â€œVÃ¡ltozÃ³k Ã¡tadÃ¡sa â€“ I.â€** (Passing Variables â€“ I):

---

### ğŸ”„ Passing Variables to a Program

- If we assign a value to a variable **before launching our program**:
  - The program **wonâ€™t be able to read** it,
  - Nor will it be able to **modify** it.

- Using the **`export`** command, we can **export the variable**:
  - This way, the program **will be able to read** it,
  - But it can **only modify a local copy** of the variable within the program.

---

This is essential for understanding environment variables and subprocess behavior in shell scripting. Want an example to see this in action?


Here's the English translation of the slide **â€œVÃ¡ltozÃ³k Ã¡tadÃ¡sa â€“ II.â€** (Passing Variables â€“ II):

---

### ğŸ“ Task:
- Assign values to the variables `DIR1`, `DIR2`, `F1`, `F2`, `SZ`, then:
  - Create the directory structure: `DIR1`, and inside it `DIR2`.
  - Inside `DIR2`, create file `F1` containing the text stored in `SZ`.
  - Also create file `F2`, which should contain a long recursive listing starting from `DIR1`.

---

### âœ… Solution:
```bash
export DIR1=some_value   # Same for the others, but from outside the program!
                         # The program will only be able to read these variables!

mkdir -p "$DIR1/$DIR2"
echo "$SZ" > "$DIR1/$DIR2/$F1"
ls -lR "$DIR1" > "$DIR1/$DIR2/$F2"
```

---

Let me know if you'd like a shell script version of this or an explanation of each command!


Here is the English translation of the slide **"Programok visszatÃ©rÃ©si Ã©rtÃ©ke â€“ I."** (Program Return Values â€“ I):

---

### **Program Return Values â€“ I**

- The `return` statement in the `main` function of C programs sets the programâ€™s return value.
  - In case of no error, it returns **0**.
  - In case of error, it returns an **error code**.
  - After running the program, we can get this value from the special variable **`$?`**.

Examples:
```bash
ls existing_file         # ls van_ilyen_file
echo $?                  # â†’ 0

ls non_existing_file     # ls nincs_ilyen_file
echo $?                  # â†’ 2
```

- The `ls` command returned an error code 2 when the file did not exist.

---

Let me know if you want the list of common error codes or examples in a script!


Here is the English translation of the slide **"Programok visszatÃ©rÃ©si Ã©rtÃ©ke â€“ II."** (Program Return Values â€“ II):

---

### **Program Return Values â€“ II**

- **0** means successful execution â€” this is considered a **true** value.
- Any **non-zero** value indicates an error â€” this is considered a **false** value.
- The `true` command: its return value is always **0**.
- The `false` command: its return value is always **1**.

---

This logic is especially important when writing shell scripts and using conditional statements. Let me know if youâ€™d like to see examples with `if` statements or conditionals!


Here is the English translation of the slide **"ElÃ¡gazÃ¡s (if) â€“ I."** (Branching (if) â€“ I):

---

### **Branching (if) â€“ I**

- The program can branch based on the **return value**.

#### **Syntax:**
- `if command; then command_if_true [; else command_if_false ]; fi`
- A newline can be used instead of `;` (and this is recommended).

#### **How it works:**
- The command runs.
- If the **return value is 0** (true), then `command_if_true` is executed.
- Otherwise, `command_if_false` is executed.

---

Would you like an example script showing this in action?

Here's the **English translation** of the slide **"ElÃ¡gazÃ¡s (if) â€“ II."** (Branching (if) â€“ II):

---

### **Branching (if) â€“ II**

#### **Task:**
- Print whether a given pattern appears in a file or not.

#### **Solution:**
```bash
if grep -q pattern file
then
    echo appears
else
    echo does not appear
fi
```

--- 

Let me know if you'd like the explanation of each part too!

Here is the **English translation** of the slide **"A test utasÃ­tÃ¡s â€“ I."** ("The `test` Command â€“ I"):

---

### **The `test` Command â€“ I**

- The `test` command can check:
  - Whether the length of a string is 0.
  - Whether a file exists.
  - What type a file is (regular file, directory, link, etc.).
  - What the file permissions are.
  - Whether two numbers are equal, or which is greater.
  - Whether two strings are equal.

- The answer is returned in the exit status (0: yes, 1: no).

- The `test` command is especially useful in combination with `if`.

---

Let me know if you want example usages or explanation of specific test options!

Here is the **English translation** of the slide **"A test utasÃ­tÃ¡s â€“ II."** ("The `test` Command â€“ II"):

---

### **The `test` Command â€“ II**

- **Task:**
  - Check whether the entry exists.

- **Solution:**
  ```bash
  if test -e file_name
  then
      echo Exists
  else
      echo Does not exist
  fi
  ```

--- 

Let me know if you'd like this turned into a summary or a practice sheet!

Here's the **English translation** of the slide **"A test utasÃ­tÃ¡s â€“ III."** ("The `test` Command â€“ III"):

---

### **The `test` Command â€“ III**

- **Task:**
  - Extend the previous task so that it checks whether the entry is a directory or not.

- **Solution:**
  ```bash
  if test -e file_name
  then
      echo Exists
      if test -d file_name
      then
          echo And it is a directory
      else
          echo And it is not a directory
      fi
  else
      echo Does not exist
  fi
  ```

---

Let me know if you'd like to see a version of this with `[ ]` syntax or in another style.


Hereâ€™s the **English translation** of the slide **â€œA test utasÃ­tÃ¡s â€“ IV.â€** (â€œThe `test` Command â€“ IVâ€):

---

### **The `test` Command â€“ IV**

- The `[` command can be used instead of `test`, but in this case, you must also use the closing `]`.

- **Task:**
  - Decide whether `$1` or `$2` is the larger number.

- **Solution:**
  ```bash
  if [ "$1" -gt "$2" ]
  then
      echo The first is greater.
  else
      echo The second is greater, or they are equal.
  fi
  ```

- It is important to **separate syntactical elements by at least one space**.

---

Let me know if you'd like more examples or comparisons with `[[ ... ]]` syntax too.



Here is the **English translation** of the slide titled **â€œA test utasÃ­tÃ¡s â€“ V.â€** (â€œThe `test` Command â€“ Vâ€):

---

### **The `test` Command â€“ V**

- **Task:**
  - Decide if `$1` is an **even** or **odd** number.

- **Solution:**
  ```bash
  if [ $(($1 % 2)) -eq 0 ]
  then
      echo Even
  else
      echo Odd
  fi
  ```

- Here, `$(($1 % 2))` calculates the **remainder** of dividing `$1` by 2.
- `-eq 0` checks if the remainder is zero (i.e., even number).

---

Let me know if youâ€™d like a version with `[[ ... ]]` or additional number-related condition examples!






This slide explains the `case` statement in shell scripting, specifically for handling multiple conditional branches.

### Title:  
**TÃ¶bbszÃ¶rÃ¶s elÃ¡gazÃ¡s (case) â€“ I.**  
(Multiple branching (case) â€“ I.)

---

### Main points:

- **Purpose**:  
  A *case* expression (usually a variable) is evaluated, and based on its value, different branches (cases) are executed.

- **Syntax**:
  ```bash
  case kifejezes in
    minta1)
      parancsok1
      ;;
    minta2)
      parancsok2
      ;;
    *)
      parancsok_egyeb
      ;;
  esac
  ```
  - `kifejezes` = expression (value to match)
  - `minta1`, `minta2` = patterns to match against
  - `parancsok1`, `parancsok2`, etc. = commands to execute if matched
  - `*` = default case (optional)

- **Explanation**:
  - If the expression matches `minta1`, `parancsok1` is executed.
  - If it matches `minta2`, `parancsok2` is executed.
  - If it doesn't match any case, `parancsok_egyeb` is executed (optional default).

---

Would you like a real example using this syntax (like with user input or file type checking)?


This slide continues with **case statements in shell scripting**, using a real-world example.

---

### Title:  
**TÃ¶bbszÃ¶rÃ¶s elÃ¡gazÃ¡s (case) â€“ II.**  
(Multiple branching (case) â€“ II.)

---

### Task (**Feladat**):
- Print the **day of the week** based on a number.

---

### Solution (**MegoldÃ¡s**):
```bash
case napszam in
  0)
    echo hetfo
    ;;
  1)
    echo kedd
    ;;
  # AnalÃ³g mÃ³don a tÃ¶bbi napot is felsorolhatjuk...
esac
```

---

### Explanation:
- `napszam` is a variable holding the day number.
- If it's `0`, it prints `hetfo` (Monday).
- If it's `1`, it prints `kedd` (Tuesday).
- The rest of the days (2 to 6 for Wednesday to Sunday) can be added similarly.
- `#` introduces a comment in shell script (here it means â€œWe can list the rest similarlyâ€¦â€)

Would you like a complete version of this script with all 7 days?


This third slide demonstrates a practical application of the `case` statement in shell scripting: **converting small decimal numbers to binary**.

---

### Title:  
**TÃ¶bbszÃ¶rÃ¶s elÃ¡gazÃ¡s (case) â€“ III.**  
(Multiple branching (case) â€“ III.)

---

### Task (**Feladat**):  
- **Decimal to binary conversion** for small numbers.

---

### Solution (**MegoldÃ¡s**):
```bash
case decszam in
  0)
    binszam="000"
    ;;
  1)
    binszam="001"
    ;;
  2)
    binszam="010"
    ;;
  3)
    binszam="011"
    ;;
esac
```

---

### Explanation:
- `decszam` is the input variable (a small decimal number).
- `binszam` gets assigned the corresponding binary string.
- This could be extended to handle more numbers (e.g., up to 7 for 3-bit binary).

Would you like an extended version of this script for numbers 0â€“7, or maybe a function to do it programmatically without `case`?




This slide presents an example of using a `case` statement to implement a **menu** in shell scripting.

---

### Title:  
**TÃ¶bbszÃ¶rÃ¶s elÃ¡gazÃ¡s (case) â€“ IV.**  
(Multiple branching (case) â€“ IV.)

---

### Task (**Feladat**):  
- Create a **menu** using the `case` structure.

---

### Solution (**MegoldÃ¡s**):
```bash
case menu in
  egyik)
    # Az egyik tÃ­pusÃº mÅ±kÃ¶dÃ©s...
    ;;
  masik)
    # A mÃ¡sik tÃ­pusÃº mÅ±kÃ¶dÃ©s...
    ;;
  kilep)
    echo ViszlÃ¡t\!
    ;;
  *)
    echo Nincs ilyen menÃ¼pont.
    ;;
esac
```

---

### Explanation:
- `menu` is the variable holding the user's menu selection.
- `egyik`, `masik`, `kilep` are possible menu options.
- `*` is the **default** case for invalid inputs.
- The backslash (`\`) before the exclamation mark is used to **escape** it (avoiding shell interpretation).

Would you like a complete interactive version of this script that reads input and loops until `kilep` is selected?

This slide introduces how to **read text input** in a shell script using the `read` command.

---

### Title:  
**SzÃ¶veg bekÃ©rÃ©se**  
(Getting Text Input)

---

### Key points:

#### **Syntax**:
```bash
read valtozo1 [ valtozo2 [ â€¦ ] ]
```
- Reads a line of input and splits it into variables.
- Words are separated by whitespace.
- The **last variable** receives the **rest of the line**, even if it contains spaces.

---

#### **Explanation**:
- The command reads a line and assigns its words to the listed variables.
- Remaining content after assigning to earlier variables goes into the last one.

---

#### **Examples**:

- `read x y z`  
  - The first word goes into `x`  
  - The second word goes into `y`  
  - The rest of the line goes into `z`

- `read a`  
  - The entire line goes into `a`

---

Would you like an example of using `read` with user prompts and `case` in a combined menu system?

This slide introduces the **`for` loop** in shell scripting.

---

### Title:  
**For ciklus â€“ I.**  
(For loop â€“ I.)

---

### Key Concepts:

- Like in other languages, the `for` loop can be used in shell scripting.
- It iterates over **a predefined list of values**.

---

### **Syntax**:
```bash
for valtozo in ertek1 [ ertek2 â€¦ ]
do
  utasÃ­tÃ¡sok
done
```
- `valtozo` takes on each value in the list (`ertek1`, `ertek2`, etc.).
- The block between `do` and `done` runs once per value.

---

### **Example**:
```bash
for nap in hetfo kedd szerda csutortok pentek szombat vasarnap
do
  echo $nap
done
```
- Prints each day of the week (`nap` means â€œdayâ€ in Hungarian).
- `$nap` holds the current day's name in the loop.

---

Would you like to see how this kind of loop can work with arrays or command output as the input list?


This slide builds on the `for` loop concept in shell scripting, showing how to **loop through files in a directory**.

---

### Title:  
**For ciklus â€“ II.**  
(For loop â€“ II.)

---

### Key Idea:
- Manually listing values can be inflexible.
- Luckily, **shell patterns (globs)** like `*` can substitute this.

---

### **Task**:
- Go through all files in the current directory.
- Copy each file into a directory (name provided by the user).
- Add the `.bak` extension to each copied file.

---

### **Code Example**:
```bash
read konyvtar
mkdir $konyvtar

for file in *
do
  cp $file "$konyvtar/$file.bak"
done
```

---

### Explanation:
- `read konyvtar`: asks the user for a directory name.
- `mkdir $konyvtar`: creates the directory.
- `for file in *`: loops through every file in the current directory.
- `cp $file "$konyvtar/$file.bak"`: copies and renames each file with `.bak`.

> ğŸ’¡ **Note:** The slide uses `â€ â€` quotes â€” make sure to replace them with regular `" "` quotes in your shell script to avoid syntax errors.

Want a version of this script that also skips directories or only copies `.txt` files?

This slide shows how the `for` loop can work with **complex shell patterns** (globbing) and **multiple file types**.

---

### Title:  
**For ciklus â€“ III.**  
(For loop â€“ III.)

---

### Concept:
- Shell patterns (globs) can be more advanced.
- You can combine **multiple patterns** in a `for` loop.
- The goal here is to **count lines** in each matching file.

---

### Task:
- For every file that:
  - starts with `a` and ends with `.sh`, or
  - starts with `a` and ends with `.pl`,
- Count the number of lines in each **separately**.

---

### Example Code:
```bash
for file in a*.sh a*.pl
do
  wc -l "$file"
done
```

---

### Notes:
- `a*.sh a*.pl`: two separate patterns.
- `wc -l`: counts lines.
- Quotes (`"$file"`) handle filenames with spaces.
- **Important:** Replace smart quotes `â€ â€` with straight quotes `" "` in scripts.

Want to extend this to count all file types or summarize the total line count at the end?

This slide explains how to use the **C-style `for` loop** in shell scripting (like in Bash).

---

### Title:  
**For ciklus â€“ IV.**  
(For loop â€“ IV.)

---

### Key Concept:
You can use the `for` loop **just like in C** with initialization, condition, and increment.

---

### Syntax:
```bash
for ((i=0; i<10; i++))
do
  utasÃ­tÃ¡sok
done
```

---

### Notes:
- **Double parentheses** `(( ))` are required.
- **Inside `(( ))` you donâ€™t use `$`** for variables â€” just write `i`, not `$i`.

---

### Example:
```bash
for ((i=0; i<5; i++))
do
  echo "i = $i"
done
```

This will print:
```
i = 0
i = 1
i = 2
i = 3
i = 4
```

Want to see how to combine this with conditionals or how to create a countdown?

This slide demonstrates using **nested `for` loops** in Bash to **draw a rectangle**, with user-defined dimensions.

---

### Title:  
**For ciklus â€“ V.**  
(For loop â€“ V.)

---

### Task:
- Draw a rectangle of asterisks (`*`).
- The **width** (`szeles`) and **height** (`magas`) are read from the keyboard.

---

### Code:
```bash
read szeles
read magas

for ((y=0; y<magas; y++))
do
  for ((x=0; x<szeles; x++))
  do
    echo -n "*"
  done
  echo
done
```

---

### Explanation:
- `read szeles` and `read magas`: ask user for rectangle dimensions.
- Outer loop (`y`) iterates over rows.
- Inner loop (`x`) prints stars across the row.
- `echo -n "*"` prints stars **without a newline**.
- `echo` after the inner loop creates a newline after each row.

> âš ï¸ **Note:** Replace the curly quotes `â€*â€` with normal ASCII quotes `"*"` for the script to work.

Want to modify this to draw a hollow rectangle or add a border?



This slide explains how Bash allows **C-style syntax**, not just for loops but also for **arithmetic and logic expressions**.

---

### Title:  
**C-hez hasonlÃ³ szintaxis**  
(Syntax similar to C)

---

### Key Concepts:

#### âœ… Not just `for` loops â€” Bash supports C-style syntax for:
---

### **Arithmetic operations**:
```bash
((z = x + y))
((i++))
```
- No `$` needed inside `(( ))`.
- Supports increment, assignment, and all arithmetic operators.

---

### **Using the result of arithmetic**:
```bash
echo $((x + 5))
```
- Here, we **use `$(())` to evaluate** and substitute the result directly into a command.

---

### **Logical conditions in `if`**:
```bash
if ((x < 6))
```
- C-style logical condition used directly in an `if` statement.

---

Would you like a short script example that uses `(( ))` inside `if` and `while` together?



This slide explains **command substitution** in shell scripting â€” specifically using the **backtick** or the more modern **`$()`** syntax.

---

### Title:  
**Parancs-behelyettesÃ­tÃ©s (backtick)**  
(Command Substitution)

---

### Concept:
- Besides single (`'`) and double (`"`) quotes, there's a **third quoting style** in the shell: the **backtick** (`` ` ``).
- Anything **between backticks** is executed as a **command**, and its **output replaces** the expression.

---

### **Examples of Syntax**:

#### Legacy form:
```bash
`command`
```

#### Modern preferred form:
```bash
$(command)
```

---

### Example:
```bash
echo "Today is: $(date)"
```
This will print:
```
Today is: Thu Apr 10 16:35:00 UTC 2025
```

> âœ… The `$()` form is **recommended**, especially for **nested substitutions**, as it is more readable and robust.

Would you like a few practical use cases, like saving the output of a command to a variable or using it in filenames?

This slide explains the use of the `expr` command in shell scripting for **evaluating arithmetic and logical expressions**.

---

### Title:  
**Az `expr` parancs**  
(The `expr` Command)

---

### Key Concepts:

- `expr` evaluates **arithmetic** and **logical** expressions.
- It understands the **four basic operations**, **parentheses**, and some **logical operators**.

---

### Important Notes:

#### 1. **Basic addition**:
```bash
expr 3 + 2
```
- Outputs: `5`
- â¤ Tokens (numbers and operators) **must be separated by spaces**.

#### 2. **Integer division**:
```bash
expr 9 / 2
```
- Outputs: `4`
- â¤ Rounds **down**; only integer math.

#### 3. **Multiplication requires escaping**:
```bash
expr 5 \* 3
```
- â¤ The asterisk (`*`) must be **escaped** with `\`, otherwise the shell expands it as a wildcard.

#### 4. **Parentheses must also be escaped**:
```bash
expr \( 2 + 5 \) \* 6
```
- â¤ Parentheses are special characters in the shell, so `\(` and `\)` are required.

---

Would you like a side-by-side comparison between `expr`, `$(( ))`, and `let` for arithmetic in shell?


This slide introduces the **`while` loop** in shell scripting.

---

### Title:  
**ElÅ‘tesztelÅ‘s ciklus (while) â€“ I.**  
(Pre-test loop (while) â€“ I.)

---

### **Syntax**:
```bash
while feltÃ©tel
do
  utasÃ­tÃ¡sok
done
```

---

### Explanation:
- The **condition** (`feltÃ©tel`) is a **command** (just like in `if`).
- The loop continues **as long as the condition evaluates to true**, i.e., the command **returns 0** (success).
- Once the condition is false (command returns non-zero), the loop stops.

---

### Example Use Case:
```bash
while [ $count -lt 5 ]
do
  echo "Count is $count"
  ((count++))
done
```

This increments and prints `count` until it reaches 5.

Would you like to see a practical example like a countdown, user prompt, or file-reading loop using `while`?

This slide builds on the `while` loop concept to create a **simple clock/calendar display** in the terminal.

---

### Title:  
**ElÅ‘tesztelÅ‘s ciklus (while) â€“ II.**  
(Pre-test loop (while) â€“ II.)

---

### **Example: Simple Clock / Calendar**
```bash
while true
do
  clear
  date
done
```

---

### What it does:
- Runs **forever** (`while true`).
- **Clears the screen** with `clear`.
- Prints the **current date and time** using `date`.
- Since there's no `sleep`, it refreshes very rapidly â€” usually too fast to read.

---

### **New commands introduced**:
- `clear`: clears the terminal screen.
- `date`: shows (or sets) the system date/time.  
  - You can **format** the output with options like:
    ```bash
    date "+%Y-%m-%d %H:%M:%S"
    ```

---

Would you like a version of this script that updates every second with `sleep 1` added?


This slide explains how to use a `while` loop to **read input line by line**, either from the **keyboard** or from a **file**.

---

### Title:  
**ElÅ‘tesztelÅ‘s ciklus (while) â€“ III.**  
(Pre-test loop (while) â€“ III.)

---

### âœ… **Reading lines from the keyboard**:
```bash
while read sor
do
  # process the line stored in $sor
done
```
- Keeps reading until input ends (e.g., with `Ctrl+D`).
- `sor` (Hungarian for "line") stores the current line.

---

### âœ… **Reading lines from a file**:
```bash
while read sor
do
  # process the line stored in $sor
done < $file
```
- Reads the contents of the file specified by the `file` variable.
- `< $file` redirects the file's contents into the loop.

---

This is a **very common pattern** for reading configuration files or processing input line-by-line in shell scripts.

Would you like an example that counts lines or filters specific content (like only showing lines with "error")?

This slide demonstrates a practical use of a `while` loop to **analyze a file line by line**, categorizing lines based on their **starting character**.

---

### Title:  
**ElÅ‘tesztelÅ‘s ciklus (while) â€“ IV.**  
(Pre-test loop (while) â€“ IV.)

---

### **Goal:**
Count how many lines in a file:
- start with **"a"**
- start with **"b"**
- and how many are **other**

---

### **Script Breakdown**:
```bash
aval=0; bvel=0; egyeb=0         # Initialize counters

while read sor
do
  if echo "$sor" | grep -q ^a
  then
    ((aval++))
  elif echo "$sor" | grep -q ^b
  then
    ((bvel++))
  else
    ((egyeb++))
  fi
done < "$1"                     # Read from file passed as argument

echo $aval $bvel $egyeb         # Output results
```

---

### Explanation:
- `"$1"` is the **first script argument** (the filename).
- Each line is stored in the variable `sor`.
- `grep -q ^a` checks if the line **starts with "a"**.
- The counters `aval`, `bvel`, and `egyeb` are incremented accordingly.
- Finally, the script **prints the counts**.

> âš ï¸ **Note:** Replace smart quotes (`â€`) with standard quotes (`"`), or the script won't run in a shell.

---

Would you like a version using `case` instead of `grep`, which might be faster and more idiomatic for this use case?

This slide explains different ways to check if a **string matches a regular expression** in shell scripting.

---

### Title:  
**Illeszkedik-e egy sor egy regexpre?**  
(Does a line match a regex?)

---

### ğŸ” **Approaches for regex matching:**

#### âœ… **Using `grep` (as in the earlier example)**:
```bash
if echo "$sor" | grep -q ^a
```
- Checks if the line starts with `a`.

---

#### âœ… **Using `expr` directly**:
```bash
if expr "$sor" : ^a > /dev/null
```
- `expr "$sor" : REGEX` returns the length of the match.
- Output is redirected to `/dev/null` to suppress it.
- Returns success if matched.

---

#### âœ… **Using `expr` with arithmetic-style test**:
```bash
if (($(expr "$sor" : ^a)))
```
- `expr` returns a number (length of the match).
- `$(...)` captures the value.
- `((...))` tests if it's non-zero â†’ true if matched.

---

### âœ… Summary:
- These methods are alternatives to `grep`, useful in performance-sensitive or POSIX-compatible scripts.
- Avoid using smart quotes (`â€`) in scripts â€” replace with standard quotes (`"`).

Would you like a benchmark comparison of `grep` vs `expr` in large file loops, or examples using Bashâ€™s `[[ ... =~ ... ]]` for regex matching?

This slide introduces how to handle **arbitrary numbers of parameters** in a shell script.

---

### Title:  
**TetszÅ‘leges mennyisÃ©gÅ± paramÃ©ter â€“ I.**  
(Arbitrary number of parameters â€“ I.)

---

### ğŸ”¢ Special Parameter Variables:

#### 1. **Number of parameters**:  
```bash
$#
```
- Stores the **number of arguments** passed to the script.
- Example:
```bash
echo "A programnak $# darab paramÃ©tert adtÃ¡l Ã¡t."
```
(You gave $# parameters to the program.)

#### 2. **All parameters**:
```bash
$@
```
- Represents **all parameters**, **each as a separate word**.

---

### ğŸ” Iterating over parameters:
```bash
for p in "$@"
do
  echo "Ãtadott paramÃ©ter: $p"
done
```

- Loops over each argument.
- Prints it one by one.

> âš ï¸ Be sure to replace the **smart quotes** (`â€`) in the script with standard quotes (`"`).

---

Would you like to see the difference between `$@` and `$*`, or an example where you pass parameters like filenames or options?

This slide explains how to process an **arbitrary number of command-line arguments** using the `shift` command in shell scripting.

---

### Title:  
**TetszÅ‘leges mennyisÃ©gÅ± paramÃ©ter â€“ II.**  
(Arbitrary number of parameters â€“ II.)

---

### ğŸ”„ **`shift` command**:
- `shift` **removes the first positional parameter** (`$1`) and **shifts the rest** forward.
- After `shift`, `$2` becomes `$1`, `$3` becomes `$2`, etc.
- Optionally, you can specify how many parameters to shift:
  ```bash
  shift 2
  ```

---

### ğŸ“œ **Example:**
```bash
while [ $# -ne 0 ]
do
  echo Az aktuÃ¡lis paramÃ©ter: $1
  shift
done
```

#### What it does:
- Loops as long as the number of parameters (`$#`) is not zero.
- Prints the current parameter (`$1`).
- `shift` removes it from the list.
- Loop continues with the next parameter.

---

This is a common pattern for **manual argument parsing** in scripts.

Would you like an extended version that detects options like `--help` or `-v` and handles them differently?

This slide introduces the `tr` command, which is used in Unix/Linux to **translate, delete, or squeeze characters** from input.

---

### Title:  
**A `tr` parancs**  
(The `tr` Command)

---

### ğŸ” **Character Translation:**

```bash
tr "[a-z]" "[A-Z]"
```
- Converts all **lowercase letters to uppercase**.

```bash
tr "[A-Za-z]" "[N-ZA-Mn-za-m]"
```
- Performs **ROT13 encoding** (shifts letters 13 positions).

---

### âŒ **Character Deletion:**

```bash
tr -d [aouei]
```
- Deletes all **vowels** from input.

---

### ğŸ”‚ **Squeezing Repeated Characters:**

```bash
tr -s [A-Z]
```
- Replaces **repeated uppercase letters** with a **single occurrence**.

---

### Usage Note:
The `tr` command reads from **stdin** and writes to **stdout**.
Example:
```bash
echo "hello" | tr "a-z" "A-Z"
```
Outputs:
```
HELLO
```

Would you like examples where `tr` is used in scripts for formatting input, or alternatives like `sed`/`awk` for more complex transformations?

This slide explains the use of two useful shell commands: **`basename`** and **`dirname`**.

---

### Title:  
**Basename Ã©s dirname**  
(Basename and dirname)

---

### ğŸ§© `basename`:
- **Extracts the last component** of a given path (usually the filename).
- Example:
  ```bash
  basename /home/antiemes/proj
  ```
  Output:
  ```
  proj
  ```

---

### ğŸ“ `dirname`:
- **Removes the last component** of a given path (returns the directory path).
- Example:
  ```bash
  dirname /home/antiemes/proj
  ```
  Output:
  ```
  /home/antiemes
  ```

---

These commands are useful when:
- Splitting file paths.
- Manipulating script input/output locations.
- Working with file arguments in shell scripts.

Would you like a script example using both to move files or generate logs in a scriptable path structure?

This slide introduces **functions in Bash**, which work similarly to how they do in traditional programming languages.

---

### Title:  
**FÃ¼ggvÃ©nyek â€“ I.**  
(Functions â€“ I.)

---

### ğŸ§  Key Concepts:

- Bash functions behave like small **reusable scripts**.
- You **call them by name**.
- You can **pass parameters** just like to a script.
- These parameters are accessed via:
  - `$1`, `$2`, `$3`, ...

---

### ğŸ”§ **Syntax**:
```bash
function fuggveny_neve {
  utasÃ­tÃ¡sok
}
```

Or, without the `function` keyword:
```bash
fuggveny_neve() {
  utasÃ­tÃ¡sok
}
```

---

### âœ… Example:
```bash
function greet {
  echo "Hello, $1!"
}

greet Alice
# Output: Hello, Alice!
```

---

Would you like to see how to return values from functions or use them in larger scripts with conditionals and loops?


This slide demonstrates how to create and use a **`rot13` function** in Bash to encode and decode text using the **ROT13 algorithm**.

---

### Title:  
**FÃ¼ggvÃ©nyek â€“ II.**  
(Functions â€“ II.)

---

### ğŸ§© **Goal:**
1. Define a `rot13` function.
2. Read the input file given as the **1st argument**.
3. Encode it with `rot13`.
4. Save it to the **2nd argument** file and **display** it on the screen.
5. Decode it back to the screen.

---

### ğŸ› ï¸ **Function Definition**:
```bash
function rot13 {
  tr "[A-Za-z]" "[N-ZA-Mn-za-m]"
}
```
> âš ï¸ Replace smart quotes `â€` with normal quotes `"`, or the script will fail.

---

### â–¶ï¸ **Usage Example**:
```bash
cat "$1" | rot13 | tee "$2"    # Encode input file, save to $2, and display
cat "$2" | rot13               # Decode the saved content and display
```

---

### ğŸ’¡ Notes:
- `tee` writes the output **to both a file and stdout**.
- This is a great demo of using a Bash function in a **pipeline**.

Would you like a version that includes error checking (e.g. file exists, correct argument count)?


This slide introduces **`sed`**, the **stream editor** â€” a powerful Unix tool for **automated text manipulation**.

---

### Title:  
**A sed (stream editor) â€“ I.**

---

### ğŸ§© What is `sed`?

- A tool for editing **text streams** non-interactively.
- Commonly used for **search/replace**, **deleting**, or **transforming** lines in files or stdin.

---

### âš™ï¸ **Scopes of operation** (`HatÃ¡skÃ¶rÃ¶k`):

- First/last line or specific intervals:  
  e.g. `1,3d` â†’ delete lines 1 to 3
- Even/odd numbered lines
- Lines matching a specific **pattern**
- Ranges between two **matching patterns**

---

### ğŸ› ï¸ **Operations** (`MÅ±veletek`):

- **Deleting** or **printing** lines
- **Transforming** lines (substitution, rearrangement)

---

### ğŸ§  **Interesting facts**:

- Sed is so expressive it can be used like a **mini programming language**.
- You can even write games in it (like **Sokoban**) [Link](http://sed.sourceforge.net/local/games/)

---

### ğŸ“š Bonus:
- Great collection of useful one-liners:  
  [Sed One-liners Collection](http://www.catonmat.net/blog/wp-content/uploads/2008/09/sed1line.txt)

---

Would you like to see practical `sed` examples like:
- replacing text in a file
- deleting blank lines
- modifying specific lines by number or pattern?


This slide focuses on the **most common use of `sed` â€” substitution**, which is used in 99% of practical cases.

---

### Title:  
**A sed (stream editor) â€“ II.**

---

### ğŸ” **Substitution Format:**
```bash
sed 's/pattern/replacement/'
```

#### Breakdown:
- `s` = substitute
- `pattern` = regex to search for
- `replacement` = what to replace it with

---

### ğŸ”§ Tips:
- The `/` delimiter can be **replaced** with another character (like `#` or `:`) if it simplifies the syntax:
  ```bash
  sed 's#path/old#path/new#'
  ```

---

### ğŸ”„ **Optional Flags** after the last delimiter:
- `g` â€“ global substitution (replaces **all** matches on a line)
- `i` â€“ case-insensitive matching

---

### âœ… Example:
```bash
echo "apple apple" | sed 's/apple/banana/g'
```
Outputs:
```
banana banana
```

---

Would you like a few more `sed` substitution examples like using capture groups or working on multiple files in-place?










