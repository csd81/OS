The text **"OperÃ¡ciÃ³s rendszerek gyakorlat"** translates to:

**"Operating Systems Practice"** in English.

Here's a detailed explanation of the slide content translated and expanded:

---

### **What will we learn about?**

#### â— Using one of the most common command interpreters (the Bash shell) in Linux/Unix systems:
- **Essential commands**  
  You will learn frequently used commands in the terminal (e.g., `ls`, `cd`, `cp`, `mv`, `rm`, etc.) which are vital for interacting with the system.

- **"One-liner programs"**  
  These are short, powerful command combinations written in a single line (often using pipes `|`, redirection, etc.) to automate tasks or process data quickly.

- **Shell scripts (hÃ©jprogramok)**  
  These are script files written in Bash that automate a sequence of commands. Youâ€™ll learn how to write and execute them for more complex automation.

#### â— About the Perl programming language:
- **Basic syntax**  
  Introduction to how Perl code is writtenâ€”variables, data types, control structures (like `if`, `for`, etc.).

- **Important functions**  
  Learning key built-in functions that make Perl powerful for tasks like text processing, file handling, and more.

---

This slide is part of a practical course titled *"OperÃ¡ciÃ³s rendszerek gyakorlat"* ("Operating Systems Practice") and seems to focus on essential scripting skills for system administration or automation tasks.


Here is the translation and explanation of the slide titled **"MiÃ©rt kell ez nekÃ¼nk?"** â€“ *"Why do we need this?"*:

---

### **Why do we need this?**

- **(Besides the fact that there are assignments and quizzes based on this...)**  
  It humorously notes that this knowledge is required for course tasks and evaluations.

- **There are far more Linux/Unix systems running than most people think.**  
  Some tasks can only be solved via the terminal. Sooner or later, youâ€™re likely to encounter these situations.

- **The terminal is highly efficient for daily tasks.**  
  Itâ€™s a flexible environment and can provide very concise solutions to many problems.

- **For writing one-time-use programs, and for system administration...**  
  This suggests the utility of scripting in automating tasks or solving problems quickly without building full applications.

- **To get familiar with scripting languages.**  
  Learning scripting helps broaden your programming and system interaction skills.

---

This slide is essentially arguing for the practical relevance and long-term usefulness of terminal and scripting skills, especially in real-world IT, system admin, and development tasks.

### TL;DR â€“ **Where can we practice?**

You can practice **anywhere Bash is available**, including:

- **Glomer** â€“ the official platform for assignments and tests.
- **Your own Linux system** â€“ useful for other courses too.
- **Virtual machine** â€“ safe to experiment since mistakes donâ€™t harm the host system.
- **Live system** â€“ can practice on a borrowed machine without leaving traces.


### **Additional Help**

Here are some useful resources to support your learning:

- [linuxconfig.org Bash scripting tutorial for beginners](https://linuxconfig.org/bash-scripting-tutorial-for-beginners)  
  Great for learning basic Bash scripting from scratch.

- [perltutorial.org](https://www.perltutorial.org)  
  A dedicated site for learning Perl programming.

- [TutorialsPoint Perl guide](https://www.tutorialspoint.com/perl/index.htm)  
  Another comprehensive Perl tutorial.

- **(Catch-up sessions)**  
  Implies that extra help or remedial sessions might be available if you fall behind.

---

These resources are great for self-study alongside the course material.


Hereâ€™s the translated and summarized content of the slide titled **"BelÃ©pÃ©s egy Unix rendszerbe"** â€“ *"Logging into a Unix system"*:

---

### **Logging into a Unix System**

- **In general:**
  - Done with a **username + password** pair.
  - **Multiple users can log in at the same time**.
  - One user can **have multiple sessions** open simultaneously.

- **Users are separated from each other:**
  - For example, each user has their own **"home" directory**.

- **You can use either a graphical or text-based interface:**
  - A terminal launched in a **graphical interface is equivalent** to a real, text-based terminal.

---

This explains the basics of Unix multi-user access, session management, and terminal usage.


Hereâ€™s the translated and summarized content of the slide titled **"Parancsok bevitele"** â€“ *"Entering Commands"*:

---

### **Entering Commands**

- **Commands are typed after the prompt.**
- The **prompt ends with `$`** (normal user) or **`#`** (root user).
- Entered commands can be edited using **arrow keys**, **backspace**, **delete**, etc.
- Use the **up/down arrows** to scroll through previously entered commands.
- Use **Ctrl + R** to **search past commands** by typing part of the command.
- The **`history`** command lists previously entered commands, each with a number.
  - `!12` â€“ Executes command number 12.
  - `history -c` â€“ Clears the command history.

---

This slide explains how to interact with the terminal command line efficiently, including editing and recalling commands.

Hereâ€™s the translated and summarized content of the slide titled **"EgyÃ©b hasznos billentyÅ±parancsok"** â€“ *"Other Useful Keyboard Shortcuts"*:

---

### **Other Useful Keyboard Shortcuts**

- **Ctrl + C**: Terminates the currently running program. *(May not always work.)*
- **Ctrl + L**: Clears the screen, but the command being edited remains.
- **Tab**: Attempts to autocomplete the command.
- **Double Tab**: If autocomplete isn't clear, pressing Tab again will list the possible options.

---

These shortcuts are essential for efficient work in the terminal.


Hereâ€™s the translated and summarized content of the slide titled **"A Unix fÃ¡jlrendszer"** â€“ *"The Unix Filesystem"*:

---

### **The Unix Filesystem**

- It uses a **tree structure** with a **single common root directory** (there are no drive letters like in Windows).
- **Everything is a file** in Unix. There are several file types:

#### File types:
- **Regular file** â€“ normal data file.
- **Directory** â€“ a special file that contains file listings.
- **Other special files:**
  - **Hard link** â€“ alternative name pointing to the same data.
  - **Soft link (symbolic link)** â€“ shortcut pointing to another file.
  - **Character and block devices** â€“ represent hardware devices.
  - **FIFO** â€“ a special file for named pipes (inter-process communication).

---

This slide highlights the unified, file-based approach of Unix systems, which treats almost all system elements as files.


Hereâ€™s the translated and summarized content of the slide titled **"ElÃ©rÃ©si utak"** â€“ *"File Paths"*:

---

### **File Paths**

- The **root directory is represented by `/`**.
- Subdirectories are also separated by the `/` symbol.

#### **Examples:**

- **Absolute paths** (start from the root `/`):
  - `/bin`
  - `/usr/bin/perl`
  - `/home/antiemes/proba/olvassel.txt`

- **Relative paths** (relative to the current directory):
  - `proba/olvassel.txt`

---

This slide explains how directory paths work in Unix-like systems, distinguishing between **absolute** and **relative** paths using the `/` separator.




Hereâ€™s the translated and summarized content of the slide titled **"SpeciÃ¡lis elÃ©rÃ©si utak"** â€“ *"Special File Paths"*:

---

### **Special File Paths**

- `.` (dot): Refers to the **current directory**
- `..` (double dot): Refers to the **parent directory** (one level up)
- `~` (tilde): Refers to the **current user's home directory**

#### **Examples:**
- `./elso.sh` â†’ the `elso.sh` file in the current directory
- `../doksi.txt` â†’ the `doksi.txt` file in the parent directory
- `../../kep/szep.jpg` â†’ the `szep.jpg` file in the `kep` directory two levels up

---

This slide helps you understand how to navigate and reference directories and files in relation to your current working directory in Unix-like systems.



Hereâ€™s the translated and summarized content of the slide titled **"MozgÃ¡s a kÃ¶nyvtÃ¡rak kÃ¶zÃ¶tt"** â€“ *"Navigating Between Directories"*:

---

### **Moving Between Directories**

- Use the `cd` (change directory) command:
  ```
  cd path_to_directory
  ```

#### **Examples:**

- `cd /` â†’ goes to the **root directory**
- `cd ..` â†’ moves **up one level**
- `cd /ez/az/amaz` â†’ navigates to `/ez/az/amaz` **from the root**
- `cd ez/az/amaz` â†’ navigates to `ez/az/amaz` **relative to the current directory**
- `cd ~/ez/az/amaz` â†’ navigates to `ez/az/amaz` **from your home directory**

---

This slide explains how to use the `cd` command with absolute and relative paths in Unix/Linux.

Hereâ€™s the translated and summarized content of the slide titled **"Az aktuÃ¡lis kÃ¶nyvtÃ¡r"** â€“ *"The Current Directory"*:

---

### **The Current Directory**

- You can check it using the **`pwd`** command (print working directory).
- The current directory usually appears in the **command prompt**.

#### **Example prompt:**
```
[antiemes] [Flow] [/mnt/proj/OS_new] [$]
```
- Here, `/mnt/proj/OS_new` is the **current working directory**.

---

This slide explains how to find out which directory you're currently in, using both the `pwd` command and the terminal prompt.

Hereâ€™s the translated and summarized content of the slide titled **"KÃ¶nyvtÃ¡rak tartalmÃ¡nak listÃ¡zÃ¡sa"** â€“ *"Listing Directory Contents"*:

---

### **Listing Directory Contents**

- Done using the **`ls` command**.
- The `ls` command accepts many **parameters** that control:
  - **What** to list â€“ using **paths**
  - **How** to list â€“ using **options (flags)**

- If you **donâ€™t give any parameters**, it simply lists the **current directory**.
- You can also specify **one or more paths** (file or directory names), and it will list those.

---

This slide introduces the `ls` command, which is essential for viewing files and directories, with flexibility through arguments and options.

Hereâ€™s the translated and summarized content of the slide titled **"Az ls parancs kapcsolÃ³i â€“ I."** â€“ *"Options for the `ls` Command â€“ I."*:

---

### **Useful `ls` Command Options**

- `-l` *(long)* â€“ long listing format, shows detailed info (permissions, size, date, etc.)
- `-a` *(all)* â€“ includes hidden entries (files starting with a dot)
- `-h` *(human)* â€“ human-readable file sizes (e.g., KB, MB instead of just bytes)
- `-1` â€“ displays output in a **single column**
- `-R` *(recursive)* â€“ lists directories and all their contents recursively
- `-d` *(directory)* â€“ lists the **directory itself**, not its contents

> Additionally, there are **many more possible options** to explore.

---

This slide helps you get more out of the `ls` command by adjusting how and what it displays.








Hereâ€™s the translated and summarized content of the slide titled **"Az ls parancs kapcsolÃ³i â€“ II."** â€“ *"Options for the `ls` Command â€“ II."*:

---

### **Combining `ls` Options**

- **Options can be combined**, for example:
  - `-a -l` â†’ long listing with hidden files
  - `-al` â†’ same as above, shorthand version
  - `-alh` â†’ same, but with human-readable file sizes

### **You can also specify one or more paths along with the options:**

- `ls -l /` â†’ gives a **long listing** of the root directory
- `ls -R /home/antiemes/stuff` â†’ **recursively lists** the specified directory

---

This slide explains how to **combine options** and **use them with paths** for more powerful usage of the `ls` command.

### **TL;DR â€“ `ls -l` Long Listing Format**

- Example output:
  ```
  total 16
  -rw-r--r-- 1 antiemes users 2650 Feb  6 16:45 BlinkAppC.nc
  -rw-r--r-- 1 antiemes users 2924 Feb  6 16:45 BlinkC.nc
  drwxr-xr-x 3 antiemes users   60 Feb  6 16:45 build
  -rw-r--r-- 1 antiemes users   42 Feb  6 16:45 Makefile
  -rw-r--r-- 1 antiemes users  678 Feb  6 16:45 README.txt
  ```

- `total 16`: total disk space used (in blocks)
- Each line after that contains **7 columns**, showing:
  1. File type & permissions
  2. Number of links
  3. Owner
  4. Group
  5. File size (in bytes)
  6. Last modified date & time
  7. File or directory name

This is how you interpret detailed file information using `ls -l`.

### **The 7 Columns of `ls -l` Output**

Each line of `ls -l` contains these 7 fields:

1. **Type and permissions** (e.g., `-rw-r--r--`) â€“ will be discussed later
2. **Link count** â€“ number of hard links to the file/directory
3. **Owner** â€“ the user who owns the file
4. **Group** â€“ the group that owns the file
5. **Size in bytes** â€“ can be changed to human-readable (`-h` option)
6. **Date** â€“ last modification time (default)
7. **Name** â€“ the filename or directory name

---

This slide breaks down the structure of a long listing in the terminal to understand each piece of information shown.


### **Entry Type (BejegyzÃ©s tÃ­pusa)**

- The **first character** in the `ls -l` output indicates the **type of file**, followed by three sets of **three characters** representing permissions.

---

### **File Types:**

| Symbol | Meaning                |
|--------|------------------------|
| `-`    | Regular file           |
| `d`    | Directory              |
| `l`    | Symbolic (soft) link   |
| `c`    | Character device       |
| `b`    | Block device           |
| `s`    | Socket                 |
| `p`    | FIFO (named pipe)      |

> `*` â€“ Listed for completeness, not commonly used in daily tasks.

---

This slide helps you interpret the first character in a long listing (`ls -l`) to identify file types in Unix/Linux.

### **Permissions (JogosultsÃ¡gok)**

---

- **Permissions are shown in 3 groups of 3 characters each:**
  - For **owner (u)**, **group (g)**, and **others (o)**

#### **Permission symbols:**
- `r` â€“ read permission
- `w` â€“ write permission
- `x` â€“ execute permission
- `-` â€“ permission **not granted**
- *(Other letters exist, but are not covered here.)*

---

- **Execute permission** has a special meaning for **directories**:  
  It means **you can enter (access) the directory**.

---

This slide explains how file and directory permissions work in Unix/Linux using symbolic notation.


### **Internal Documentation (BelsÅ‘ dokumentÃ¡ciÃ³)**

---

#### **`man` (manual) command:**
- Usage: `man [section] command_or_topic`
- The output is displayed with **`less`** (or `more`), which allows **scrolling** and **searching**.

#### **Other help options:**
- Most programs also support:
  - `-h`
  - `-help`
  - `--help`  
  These often display useful information about usage and options.

#### **Manual pages are also available online.**

---

### **Examples:**
- `man ls` â€“ help for the `ls` command  
- `man man` â€“ help for using the `man` command itself  
- `man 7 regex` â€“ documentation on **regular expressions** in section 7

---

This slide introduces built-in tools for accessing documentation directly from the command line.



### **Creating a Directory (`mkdir`)**

---

#### **Command syntax:**
```bash
mkdir path_to_directory
```

---

### **Explanation:**

- If the given path is **just one directory name**, it will be created in the **current directory**.

- If a **nested path** is specified (e.g., `a/b/c`), it will **only be created if the beginning parts already exist**.  
  - Use the `-p` option to **create all missing directories** in the path:
    ```bash
    mkdir -p a/b/c
    ```

- You can **create multiple directories at once** by listing them:
  ```bash
  mkdir dir1 dir2 dir3
  ```

---

This slide introduces `mkdir`, a basic but essential command for working with directories in Unix/Linux systems.



### **Creating Files Without Content (`touch`)**

---

#### **Command syntax:**
```bash
touch name1 [name2 [name3 ...]]
```

---

### **Key Points:**

- If the files **donâ€™t exist**, they are **created empty**.
- If **no path** is given, the file is created in the **current directory**; otherwise, itâ€™s placed at the specified location.
- If the file **already exists**, it is **not overwritten**, but its **last modified timestamp is updated**.

---

This command is useful for creating empty files quickly or updating timestamps on existing ones.


### **Copying Files (`cp`) â€“ Part I**

---

#### **Command syntax:**
```bash
cp [options] source target
```

---

### **Behavior Overview:**

- There are multiple usage cases, but the logic is similar:
  - **The source is copied to the target location**

---

### **Common Scenarios:**

1. **Source: existing file, Target: new (non-existent) file**  
   - The target file is created and gets the same content as the source.

2. **Source: existing file, Target: existing file**  
   - The target file is **overwritten** with the source fileâ€™s content.

3. **Source: existing file(s), Target: existing directory**  
   - The file(s) are **copied into the target directory**.
   - If a file already exists there, it will be **overwritten**.

---

You can also specify full paths. If none is given, the current directory is used by default.


### **Copying Files (`cp`) â€“ Part II**

---

### **Copying Directories**
- To copy directories, use the `-r` (or `--recursive`) option:
  - `-r` = recursive
  - Copies the **contents** of the directory as well

---

### **Using Wildcards (Shell Patterns) in Source Names**

- Wildcards can help match multiple files:
  - `*.txt` â†’ copies all files ending in `.txt`
  - `*ab*` â†’ copies files that **contain "ab"** in their names
  - `vala*` â†’ copies files that **start with "vala"**
  - `*a*a*` â†’ copies files that contain **two "a" letters**

> âš ï¸ Important note:  
> These patterns are **expanded by the shell** into a list of matching files/directories **before** `cp` runs. So `cp` just receives a list of items to copy â€“ just like if you listed them manually.

---

This slide expands on copying functionality and shows how to efficiently select multiple files using shell wildcards.


### **Displaying Text with `echo` â€“ Part I**

---

#### **Basic usage:**
```bash
echo text
```

- Example:  
  `echo szoveg` â†’ just prints the word `szoveg`

- Multiple words also work:  
  `echo ez tobb szavas` â†’ prints: `ez tobb szavas`

---

### **Spacing behavior:**

```bash
echo itt     sok     space     van
```
- Output: `itt sok space van` â†’ **extra spaces are collapsed**

---

### **Why?**
- `echo` treats each word as a **separate argument**.
- It prints all arguments separated by **a single space**.

---

### **Solution: Use quotes**
```bash
echo "itt     sok     space     van"
```
- The entire string is treated as **one argument**, so all spacing is preserved.

---

This slide explains how `echo` handles arguments and how to preserve formatting with quotation marks.



### **Displaying Text with `echo` â€“ Part II**

---

### **Line Ending and Escape Sequences**

- By default, `echo` **adds a newline** at the end of the output.
  - Use `-n` to **suppress the newline**.

- Use `-e` to **enable interpretation of escape sequences**, such as:
  - `\t` â†’ tab
  - `\n` â†’ newline

---

### **Examples:**

```bash
echo -e "Ezt\tszepen\ttabulalva\tirja\tki."
```
â†’ Outputs the words separated by tabs.

```bash
echo -e "Minden\nszot\nuj\nsorba\nteszunk."
```
â†’ Puts each word on a **new line**.

---

This slide shows how to control formatting and special characters in terminal output using `echo`.



### **Shell Patterns (Wildcards)**

---

#### **Using `*` in commands like `echo` or `cp`:**
- `echo *` does **not print an asterisk**, but a **list of files and directories** in the current folder.
- The **shell replaces** the `*` with all matching filenames before the command runs.
- This applies to **other commands** too, like `cp` â€“ they donâ€™t see the `*`, they get a **list of files**.

---

### **How to prevent expansion (escape `*`):**

To print an actual asterisk, you can escape it:

```bash
echo "*"
echo '*'
echo \*
```

These commands **print the literal `*`** instead of expanding it into file names.

---

This slide explains shell expansion behavior and how to escape wildcard characters when needed.




Hereâ€™s a **TL;DR** summary of the slide titled **"TÃ¶rlÃ©s (rm)"** (Deletion with `rm` command):

---

### `rm` [options] file_and_directory_list
- Comes from the word **"remove"**.
- Paths can be **absolute** or **relative**. Defaults to the current directory.
- **Shell patterns** (wildcards) are allowed.
- **Directories** can be deleted with the `-r` (recursive) option â€” this deletes the directory and all its contents.
- For **read-only files**, it asks for confirmation; otherwise, it deletes without prompting.
  - `-f`: **never asks**, force deletion.
  - `-i`: **always asks** before deleting.

---

Let me know if you want a quick command reference or example usage too!

Here's a TL;DR translation and summary of the slide content:

---

### ğŸ“ Deleting a Directory (`rmdir`)

- **Syntax**: `rmdir directory [directory2 [directory3 â€¦]]`
- **Important Notes**:
  - Only deletes **empty** directories.
  - Supports **relative** or **absolute** paths, as well as **shell patterns**.
    - Example: `rmdir *` deletes all **empty directories** in the current location, leaving others untouched.

---

Let me know if you want a comparison with `rm -r` or examples in a script.




Here's a TL;DR summary and translation of the slide:

---

### ğŸ”„ Rename or Move (`mv`)

#### `mv source_file target_file`
- If the **source and target** are in the **same directory**, it **renames** the file.
- If they are in **different directories**, it **moves** the file.
- If the **target file exists**, it will be **overwritten**.

#### `mv source_files_and_dirs target_directory`
- Moves the listed **files and directories** into the **target directory**.
- **Shell patterns** can also be used here (e.g. `mv *.txt backup/`).

---

Let me know if you want command line examples or common use cases!


Here's a TL;DR summary and translation of the slide:

---

### ğŸ“„ Displaying File Content (`cat`)

#### `cat [file1 [file2 [file3 â€¦ ]]]`
- Name comes from **"concatenate"** (allegedly).
- Outputs the **contents of files in sequence**.
- Even this simple command has **many options** (e.g., it can **number lines**).
- Without parameters, it reads input from **standard input (stdin)**.
  - Press **Ctrl+D** to signal the end of input.

---

Let me know if you want examples of `cat` with options like `-n`, `-A`, or redirection.


Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ“– Paginated Content Display (`less`, `more`)

#### `less file`
- Like `man`, lets you **scroll up/down**, **search**, etc.
- The `man` command actually **uses `less`** internally.

#### `more file`
- Similar to `less`.
- A bit **more limited** (the slide jokes: "a bit dumber").

---

Let me know if you want a quick keybinding cheat sheet for `less` or when to use `more` over `less`.


Here's a TL;DR summary and translation of the slide:

---

### ğŸ”€ Output Redirection

#### â¤ `>` Redirect to file
- Most programs print to the screen â€” you can redirect this to a **file** with `>`.
- Example:
  - `ls -l > file`
  - `ls -R > file`  
  â†’ Output goes into the file instead of the screen.
- âš ï¸ If the file already exists, it will be **overwritten**!

#### â¤ `>>` Append to file
- Example:  
  `cat a*txt >> asok`  
  â†’ Appends all files starting with "a" and ending in `.txt` to the **`asok`** file.

#### â¤ `cat > program.sh`
- Allows you to **type directly** into the file.
- You can also **paste content** from clipboard â€” very handy!

---

Let me know if youâ€™d like quick practice tasks with redirection and appending.

Hereâ€™s a TL;DR summary and translation of the slide:

---

### â¬…ï¸ Input Redirection

- Many programs expect **input from the keyboard**.
- We can redirect **standard input** so the program reads from a **file** instead.
- Syntax:  
  `program < file`
- Useful when **testing our own programs**.

âœ… Example:  
`./example < input.txt`

---

Let me know if you want to combine this with output redirection (e.g., `program < input.txt > output.txt`).

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ”— Linking Files â€“ Part I: **Soft Link (Symbolic Link)**

- A **special file** that contains the **path** to another file.
- Using this link is usually equivalent to referencing the original file/directory.  
  â†’ **Except** for operations like **rename** or **delete**.
- **Create with**:  
  `ln -s existing_file [target_dir or target_file]`
  - If target is a **file name** â†’ link is created with that name.
  - If target is a **directory** â†’ link is created in that directory using the original name.
- âš ï¸ If the **original file is deleted**, the **link becomes broken** (content is lost).

---

Let me know if youâ€™d like a demo comparing soft and hard links!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ”— Linking Files â€“ Part II: **Hard Link**

- Creates **another filename** pointing to the **same file content**.
- **Command**:  
  `ln existing_file new_file`
- Deleting one does **not delete** the actual data â€” it remains as long as **one link exists**.
- The system uses a **link counter** to track how many links reference the same content.
- ğŸ”’ Restrictions:
  - Can only be created **within the same filesystem**.
  - Cannot be created for **directories**.

---

Let me know if you want a table comparing hard vs soft links side by side.

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Modifying Permissions â€“ Part I (`chmod`)

#### Syntax:
```bash
chmod modification file1 [file2 â€¦]
```

#### Format of modification:
```bash
who [+|-] what
```

**Who:**
- `u` â€“ user (owner)
- `g` â€“ group
- `o` â€“ others
- `a` â€“ all

**What:**
- `r` â€“ read permission
- `w` â€“ write permission
- `x` â€“ execute/access permission

**Operators:**
- `+` â€“ add permission
- `-` â€“ remove permission

âœ… Example:  
`chmod u+x script.sh` â†’ gives the owner execute permission on `script.sh`

---

Want help with symbolic vs numeric modes or examples with directories?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Modifying Permissions â€“ Part II (`chmod` continued)

#### âœ… Examples (symbolic mode):
- `u+x` â€“ Give the **owner** execute permission
- `ug+w` â€“ Give the **owner and group** write permission
- `a+x` â€“ Give **everyone** execute permission
- `go-rwx` â€“ Remove **all permissions** from **group and others**, keep ownerâ€™s

---

### ğŸ§® Setting Permissions Numerically (octal mode):
- Uses **3-digit octal** numbers:  
  `[owner][group][others]`
- Values:  
  - `r = 4`, `w = 2`, `x = 1` â†’ summed per group

#### ğŸ›  Examples:
- `chmod 640 doksi.txt`  
  â†’ Owner: read/write, Group: read, Others: none
- `chmod 777 pelda.sh`  
  â†’ **Everyone can do everything**

---

Let me know if you want a quick permissions cheat sheet or a practice task!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ‘¤ Changing Ownership

#### `chown new_owner file1 [file2 â€¦]`
- Changes the **owner** of the files to `new_owner`.

#### `chown new_owner:new_group file1 [file2 â€¦]`
- Changes both the **owner** and the **group**.

#### `chgrp new_group file1 [file2 â€¦]`
- Changes just the **group**.

ğŸ” Use `-R` for **recursive** changes â€” it will apply to all subdirectories and files too.

âš ï¸ **Admin (root) privileges** are required to perform these operations.

---

Let me know if you want a visual breakdown of ownership and permission fields in `ls -l` output!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ“„ File Start and End: `head` & `tail`

#### `head [-n number] file1 [file2 â€¦]`
- Prints the **first `number` lines** of the file.
- If not specified, **defaults to 10 lines**.
- Shows the file name too (can be hidden with `-q`).

#### `tail [-n number] file1 [file2 â€¦]`
- Same as `head`, but prints the **last `number` lines**.
- Supports shell patterns as well.

#### ğŸ§ª Examples:
- `head -n 8 leiras.txt` â†’ Displays the **first 8 lines** of `leiras.txt`
- `tail readme` â†’ Displays the **last 10 lines** of `readme`

â„¹ï¸ If no file is specified, input is read from **standard input** (keyboard, pipe, etc.)

---

Want examples with live log monitoring using `tail -f`?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Pipe â€“ Part I

- Programs that **write to standard output** and those that **read from standard input** can be **connected using a pipe (`|`)**.

#### ğŸ§ª Examples:
- `ls -l | tail -n 5`  
  â†’ Shows the **last 5 lines** of the `ls -l` output.
  
- `cat olvassel.txt | head -n 5`  
  â†’ Displays the **first 5 lines** of `olvassel.txt`.

ğŸ“ Note:
- This is **almost** the same as `head -n 5 readme.txt`, but not exactly!
- When using a pipe, the receiving command (like `head`) does **not know the original file name** â€” only the data.  
  â†’ Thatâ€™s why it **canâ€™t print the file name** when piped.

---

Want to continue to part II or see how to chain multiple pipes?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Pipe â€“ Part II

You can **chain multiple commands** using pipes:

#### ğŸ§ª Examples:

- `cat pelda.txt | head -n 20 | tail -n 1`  
  â†’ Takes the **first 20 lines** of `pelda.txt`, then selects the **last line** from that.  
  âœ… **Result:** line 20 of `pelda.txt`

- `ls -l | head -n 6 | tail -n 1`  
  â†’ From the `ls -l` output, grabs the **6th line**.

---

ğŸ“Œ Piping is powerful for extracting precise parts of command outputs. Want more complex examples using `grep`, `awk`, or `cut`?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ”¢ Lines, Words, Characters Count (`wc`)

- `wc` = **word count**, but it also counts **lines** and **characters**.

#### ğŸ§© Options:
- `-l` â†’ line count
- `-w` â†’ word count
- `-c` â†’ character count

âœ… You can **combine options**, e.g.:
- `wc -wl file.txt` â†’ counts **words and lines**

ğŸ’¡ **Default behavior**: prints **all three** (lines, words, characters).

---

Want a quick demo on piping output into `wc`, like `cat file | wc -l`?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ“Š `wc` â€“ Part II

#### ğŸ§© Modes of operation:

âœ… **Via Pipe**:
- `ls -1 | wc -l` â†’ counts files/directories listed by `ls`
- `cat pelda.txt | wc -w` â†’ counts **words** in `pelda.txt`
- In piped mode, `wc` **only shows the count**, **not the file name**.

âœ… **Single file as argument**:
- `wc -c pelda.txt` â†’ counts **characters** in `pelda.txt`
- Output includes the **count** and the **file name**.

âœ… **Multiple files**:
- Lists counts **per file**, and a **total** at the end.
- Works with **lines, words, characters**, etc.
  
âœ… **Shell wildcards** (e.g. `*.txt`) work here too.

---

Let me know if you'd like some combined examples with `find`, `xargs`, or `grep`.

Hereâ€™s a TL;DR summary and translation of the slide:

---

### âœ‚ï¸ Cutting Fields (`cut`) â€“ Part I

You can **cut text** either **by character** or **by field**.

#### ğŸ”  By Character:
- `cut -c start-end`  
  â†’ returns characters in the range `[start, end]` from each line.
- `cut -c num1,num2,num3`  
  â†’ returns specific character positions (e.g. 1st, 3rd, 5th).
- You can **combine** positions and ranges:  
  `cut -c 1,4-7,9`  
  â†’ one specific, a range, and another specific character.

#### ğŸ§ª Example:
- `ls -l | cut -c 2-10`  
  â†’ Extracts the **permissions** field from `ls -l` output.

---

Would you like to see Part II for field-based cutting using delimiters (like `-d` and `-f`)?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### âœ‚ï¸ Cutting Fields (`cut`) â€“ Part II (By Field)

#### ğŸ“Œ Field-based cutting:

- `cut -d: -f 1,5 /etc/passwd`  
  â†’ Cuts **fields 1 and 5** from `/etc/passwd` using **colon (`:`)** as the **delimiter**.

- `cut -f 1,3 lista_nagy.txt`  
  â†’ Cuts **fields 1 and 3** from `lista_nagy.txt`, where fields are separated by **tabs** (default delimiter).

â„¹ï¸ If no delimiter is specified, `cut` assumes **tabs** by default.

---

Let me know if you'd like a comparison with `awk` or `csvkit` for more complex field processing!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ”¢ Sorting (`sort`)

#### ğŸ“š Basic usage:
- `cat nevek.txt | sort` â†’ sorts lines **alphabetically**
- `sort nevek.txt` â†’ same as above, no pipe needed

#### ğŸ”‘ Sort by specific field:
- `ls -l | sort -k 3` â†’ sorts by the **3rd field** (e.g. owner)

#### ğŸ”¢ Numerical sorting:
- `ls -l | sort -n -k 5` â†’ sorts by **file size**
- `ls -l | sort -n -k 5 -r` â†’ sorts by size in **reverse order**

#### ğŸ§  More complex example:
- `ls -l | sort -k 5 -n | tail -n 1`  
  â†’ shows the **largest file** in the listing

---

Let me know if you want examples for sorting CSV files or combining `sort` with `uniq`.

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Removing Duplicate Lines (`uniq`)

- If **identical lines appear consecutively**, `uniq` will keep **only one**.
- ğŸ”„ **Sorting first** is useful, since `uniq` only removes **adjacent** duplicates.

#### ğŸ§ª Example:
```bash
cat nevek.txt | sort | uniq
```

âœ… Equivalent to:
```bash
sort -u nevek.txt
```

> `sort -u` = sort **and** remove duplicates in one step.

---

Let me know if you'd like to combine this with `wc`, `cut`, or `grep` for data cleanup!


Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Filtering (`grep`) â€“ Part I

- `grep` returns lines that **match a regular expression**.  
  *(Regex details will come on a later slide.)*

- You can check if a pattern **exists** in input even **without printing matches**.

- Searches are **case-sensitive** by default â€” use `-i` to make it **case-insensitive**.

#### ğŸ§ª Usage:

**With a pipe:**
```bash
command | grep [options] pattern
```

**With a file:**
```bash
grep [options] pattern file
```

---

Let me know if you'd like help with common `grep` options like `-v`, `-r`, or `-n`!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Filtering (`grep`) â€“ Part II  
#### ğŸ§¬ Syntax Types (Regular Expressions)

#### ğŸ“˜ Basic Regex Syntax
- Characters like `?`, `+`, `{`, `|`, `(`, `)` work as **normal characters** unless escaped.
- Use **`\?`, `\+`** etc. to enable their **meta** behavior.

#### ğŸ“— Extended Regex Syntax
- Offers **more power** and convenience.
- Meta characters like `?`, `+`, `{` work **without** backslashes.
- Use with `grep -E` or `egrep`.

#### ğŸ“™ Perl Regex Syntax
- **Even more features**, e.g. `\w`, `\d`, `\s`.
- Use `grep -P` in **modern implementations**.

---

Want examples showing the difference between basic and extended syntax in practice?

Hereâ€™s a TL;DR summary and translation of the slide:

---

### ğŸ” Filtering (`grep`) â€“ Part III

#### ğŸ§° Useful Options:

- `-v` â†’ **Invert match**: return lines **not** matching the pattern  
- `-e pattern` â†’ Use this if your pattern **starts with a dash** (`-`), or to **combine multiple patterns**
- `-A num` â†’ Show **num lines after** the matching line  
- `-B num` â†’ Show **num lines before** the matching line  
- `-q` â†’ **Quiet mode**: no output, but sets exit code (âœ… useful in scripts)

---

### ğŸ“ Filename Display:

- When using pipes or a **single file**, grep **doesnâ€™t show the filename**.
- With **multiple files**, grep shows the **filename before each match**.
- Use `-H` to **force show** filenames, even with one file.  
- Use `-h` to **suppress** filenames in multi-file input.

---

Let me know if you want a visual cheat sheet or grep + regex exercises!

Hereâ€™s a TL;DR summary and translation of the slide:

---

### âš™ï¸ Processes and Jobs â€“ Part I

#### ğŸ“ The `/proc` virtual filesystem:

- Located at `/proc`, it's a **virtual filesystem** used to **interact with processes**.

- Contains **directories named by PID** (Process ID), each representing a running process.

- Inside each process's folder, you can find information like:
  - ğŸ”“ Open files
  - ğŸ“Š Memory and CPU time stats
  - ğŸ‘¤ Owner
  - ğŸ§  Other state information

- Also contains **system-wide** directories and files for querying or configuring kernel settings.

---

Let me know if youâ€™d like a tour of useful files like `/proc/cpuinfo`, `/proc/meminfo`, or `/proc/[pid]/status`.


Hereâ€™s a TL;DR summary and translation of the slide:

---

### âš™ï¸ Processes and Jobs â€“ Part II

#### ğŸ“‹ `ps` command â€” list and get info about processes

- Works based on the `/proc` virtual filesystem.

#### ğŸ”§ Common options:
- `aux`  
  â†’ Shows **all processes** with **full details**
- `w`, `ww`  
  â†’ Enables **wide output** (shows full command with arguments)
- `f`  
  â†’ Displays a **tree-like structure** (parent-child relationships)

#### ğŸ“Š The process list includes:
- Owner  
- PID  
- CPU and memory usage  
- Status  
- Name  
- And other details

---

Let me know if youâ€™d like a comparison with `top`, `htop`, or `pstree`.
 

 Hereâ€™s a TL;DR summary and translation of the slide:

---

### âš™ï¸ Processes and Jobs â€“ Part III  
#### ğŸ”ª `kill` Command

- **Send signals to processes** using:
  ```bash
  kill [-signal_number | -signal_name] PID
  ```

#### ğŸ“Œ Common signals:
- `15 (TERM)` â€“ Politely **asks the process to terminate** (default, can be ignored)
- `9 (KILL)` â€“ **Forcefully stops** the process (canâ€™t be caught or ignored)
- `17, 19, 23 (STOP)` â€“ **Pauses** the process
- `19, 18, 25 (CONT)` â€“ **Resumes** the process

---

#### ğŸ”« `killall` Command:
- Syntax:
  ```bash
  killall [-signal_number | -signal_name] process_name
  ```
- Sends the signal to **all processes matching the given name** (instead of using PIDs)

---

Let me know if you want a cheat sheet of all common signals (`kill -l`) or signal-handling in C!


Hereâ€™s a TL;DR summary and translation of the slide:

---

### âš™ï¸ Processes and Jobs â€“ Part IV  
#### ğŸ§  Managing jobs in the terminal

You can run **multiple programs as jobs** in the terminal.  
At most, **one job is in the foreground** at any time.

#### ğŸ§° Useful commands:

- `jobs`  
  â†’ Lists all **current jobs**

- `bg [number]`  
  â†’ Puts the **current or specified job** in the **background**

- `fg [number]`  
  â†’ Brings the **current or specified job** to the **foreground**

- `kill %number`  
  â†’ Sends a signal to a **job** using the **job ID** (not PID), prefixed with `%`

---

Let me know if you want to explore job control shortcuts like `Ctrl+Z`, `&`, or use cases!


Hereâ€™s a TL;DR summary and translation of the slide:

---

### âš™ï¸ Processes and Jobs â€“ Part V

#### â–¶ï¸ Running a program in the background:
- Example:
  ```bash
  xterm &
  ```
  The `&` runs the command **in the background**.

#### ğŸ›‘ Pausing an active process:
- Press **`Ctrl+Z`** to **suspend** the current foreground process.

Then you can:
- Use `fg` to bring it **back to foreground**
- Use `bg` to resume it **in the background**

âš ï¸ Some programs **disable this feature** and cannot be suspended this way.

---

Let me know if you want a quick summary of job states or signals that affect them!

