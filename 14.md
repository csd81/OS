The text **"Operációs rendszerek gyakorlat"** translates to:

**"Operating Systems Practice"** in English.

Here's a detailed explanation of the slide content translated and expanded:

---

### **What will we learn about?**

#### ● Using one of the most common command interpreters (the Bash shell) in Linux/Unix systems:
- **Essential commands**  
  You will learn frequently used commands in the terminal (e.g., `ls`, `cd`, `cp`, `mv`, `rm`, etc.) which are vital for interacting with the system.

- **"One-liner programs"**  
  These are short, powerful command combinations written in a single line (often using pipes `|`, redirection, etc.) to automate tasks or process data quickly.

- **Shell scripts (héjprogramok)**  
  These are script files written in Bash that automate a sequence of commands. You’ll learn how to write and execute them for more complex automation.

#### ● About the Perl programming language:
- **Basic syntax**  
  Introduction to how Perl code is written—variables, data types, control structures (like `if`, `for`, etc.).

- **Important functions**  
  Learning key built-in functions that make Perl powerful for tasks like text processing, file handling, and more.

---

This slide is part of a practical course titled *"Operációs rendszerek gyakorlat"* ("Operating Systems Practice") and seems to focus on essential scripting skills for system administration or automation tasks.


Here is the translation and explanation of the slide titled **"Miért kell ez nekünk?"** – *"Why do we need this?"*:

---

### **Why do we need this?**

- **(Besides the fact that there are assignments and quizzes based on this...)**  
  It humorously notes that this knowledge is required for course tasks and evaluations.

- **There are far more Linux/Unix systems running than most people think.**  
  Some tasks can only be solved via the terminal. Sooner or later, you’re likely to encounter these situations.

- **The terminal is highly efficient for daily tasks.**  
  It’s a flexible environment and can provide very concise solutions to many problems.

- **For writing one-time-use programs, and for system administration...**  
  This suggests the utility of scripting in automating tasks or solving problems quickly without building full applications.

- **To get familiar with scripting languages.**  
  Learning scripting helps broaden your programming and system interaction skills.

---

This slide is essentially arguing for the practical relevance and long-term usefulness of terminal and scripting skills, especially in real-world IT, system admin, and development tasks.

### TL;DR – **Where can we practice?**

You can practice **anywhere Bash is available**, including:

- **Glomer** – the official platform for assignments and tests.
- **Your own Linux system** – useful for other courses too.
- **Virtual machine** – safe to experiment since mistakes don’t harm the host system.
- **Live system** – can practice on a borrowed machine without leaving traces.


### **Additional Help**

Here are some useful resources to support your learning:

- [linuxconfig.org Bash scripting tutorial for beginners](https://linuxconfig.org/bash-scripting-tutorial-for-beginners)  
  Great for learning basic Bash scripting from scratch.

- [perltutorial.org](https://www.perltutorial.org)  
  A dedicated site for learning Perl programming.

- [TutorialsPoint Perl guide](https://www.tutorialspoint.com/perl/index.htm)  
  Another comprehensive Perl tutorial.

- **(Catch-up sessions)**  
  Implies that extra help or remedial sessions might be available if you fall behind.

---

These resources are great for self-study alongside the course material.


Here’s the translated and summarized content of the slide titled **"Belépés egy Unix rendszerbe"** – *"Logging into a Unix system"*:

---

### **Logging into a Unix System**

- **In general:**
  - Done with a **username + password** pair.
  - **Multiple users can log in at the same time**.
  - One user can **have multiple sessions** open simultaneously.

- **Users are separated from each other:**
  - For example, each user has their own **"home" directory**.

- **You can use either a graphical or text-based interface:**
  - A terminal launched in a **graphical interface is equivalent** to a real, text-based terminal.

---

This explains the basics of Unix multi-user access, session management, and terminal usage.


Here’s the translated and summarized content of the slide titled **"Parancsok bevitele"** – *"Entering Commands"*:

---

### **Entering Commands**

- **Commands are typed after the prompt.**
- The **prompt ends with `$`** (normal user) or **`#`** (root user).
- Entered commands can be edited using **arrow keys**, **backspace**, **delete**, etc.
- Use the **up/down arrows** to scroll through previously entered commands.
- Use **Ctrl + R** to **search past commands** by typing part of the command.
- The **`history`** command lists previously entered commands, each with a number.
  - `!12` – Executes command number 12.
  - `history -c` – Clears the command history.

---

This slide explains how to interact with the terminal command line efficiently, including editing and recalling commands.

Here’s the translated and summarized content of the slide titled **"Egyéb hasznos billentyűparancsok"** – *"Other Useful Keyboard Shortcuts"*:

---

### **Other Useful Keyboard Shortcuts**

- **Ctrl + C**: Terminates the currently running program. *(May not always work.)*
- **Ctrl + L**: Clears the screen, but the command being edited remains.
- **Tab**: Attempts to autocomplete the command.
- **Double Tab**: If autocomplete isn't clear, pressing Tab again will list the possible options.

---

These shortcuts are essential for efficient work in the terminal.


Here’s the translated and summarized content of the slide titled **"A Unix fájlrendszer"** – *"The Unix Filesystem"*:

---

### **The Unix Filesystem**

- It uses a **tree structure** with a **single common root directory** (there are no drive letters like in Windows).
- **Everything is a file** in Unix. There are several file types:

#### File types:
- **Regular file** – normal data file.
- **Directory** – a special file that contains file listings.
- **Other special files:**
  - **Hard link** – alternative name pointing to the same data.
  - **Soft link (symbolic link)** – shortcut pointing to another file.
  - **Character and block devices** – represent hardware devices.
  - **FIFO** – a special file for named pipes (inter-process communication).

---

This slide highlights the unified, file-based approach of Unix systems, which treats almost all system elements as files.


Here’s the translated and summarized content of the slide titled **"Elérési utak"** – *"File Paths"*:

---

### **File Paths**

- The **root directory is represented by `/`**.
- Subdirectories are also separated by the `/` symbol.

#### **Examples:**

- **Absolute paths** (start from the root `/`):
  - `/bin`
  - `/usr/bin/perl`
  - `/home/antiemes/proba/olvassel.txt`

- **Relative paths** (relative to the current directory):
  - `proba/olvassel.txt`

---

This slide explains how directory paths work in Unix-like systems, distinguishing between **absolute** and **relative** paths using the `/` separator.




Here’s the translated and summarized content of the slide titled **"Speciális elérési utak"** – *"Special File Paths"*:

---

### **Special File Paths**

- `.` (dot): Refers to the **current directory**
- `..` (double dot): Refers to the **parent directory** (one level up)
- `~` (tilde): Refers to the **current user's home directory**

#### **Examples:**
- `./elso.sh` → the `elso.sh` file in the current directory
- `../doksi.txt` → the `doksi.txt` file in the parent directory
- `../../kep/szep.jpg` → the `szep.jpg` file in the `kep` directory two levels up

---

This slide helps you understand how to navigate and reference directories and files in relation to your current working directory in Unix-like systems.



Here’s the translated and summarized content of the slide titled **"Mozgás a könyvtárak között"** – *"Navigating Between Directories"*:

---

### **Moving Between Directories**

- Use the `cd` (change directory) command:
  ```
  cd path_to_directory
  ```

#### **Examples:**

- `cd /` → goes to the **root directory**
- `cd ..` → moves **up one level**
- `cd /ez/az/amaz` → navigates to `/ez/az/amaz` **from the root**
- `cd ez/az/amaz` → navigates to `ez/az/amaz` **relative to the current directory**
- `cd ~/ez/az/amaz` → navigates to `ez/az/amaz` **from your home directory**

---

This slide explains how to use the `cd` command with absolute and relative paths in Unix/Linux.

Here’s the translated and summarized content of the slide titled **"Az aktuális könyvtár"** – *"The Current Directory"*:

---

### **The Current Directory**

- You can check it using the **`pwd`** command (print working directory).
- The current directory usually appears in the **command prompt**.

#### **Example prompt:**
```
[antiemes] [Flow] [/mnt/proj/OS_new] [$]
```
- Here, `/mnt/proj/OS_new` is the **current working directory**.

---

This slide explains how to find out which directory you're currently in, using both the `pwd` command and the terminal prompt.

Here’s the translated and summarized content of the slide titled **"Könyvtárak tartalmának listázása"** – *"Listing Directory Contents"*:

---

### **Listing Directory Contents**

- Done using the **`ls` command**.
- The `ls` command accepts many **parameters** that control:
  - **What** to list – using **paths**
  - **How** to list – using **options (flags)**

- If you **don’t give any parameters**, it simply lists the **current directory**.
- You can also specify **one or more paths** (file or directory names), and it will list those.

---

This slide introduces the `ls` command, which is essential for viewing files and directories, with flexibility through arguments and options.

Here’s the translated and summarized content of the slide titled **"Az ls parancs kapcsolói – I."** – *"Options for the `ls` Command – I."*:

---

### **Useful `ls` Command Options**

- `-l` *(long)* – long listing format, shows detailed info (permissions, size, date, etc.)
- `-a` *(all)* – includes hidden entries (files starting with a dot)
- `-h` *(human)* – human-readable file sizes (e.g., KB, MB instead of just bytes)
- `-1` – displays output in a **single column**
- `-R` *(recursive)* – lists directories and all their contents recursively
- `-d` *(directory)* – lists the **directory itself**, not its contents

> Additionally, there are **many more possible options** to explore.

---

This slide helps you get more out of the `ls` command by adjusting how and what it displays.








Here’s the translated and summarized content of the slide titled **"Az ls parancs kapcsolói – II."** – *"Options for the `ls` Command – II."*:

---

### **Combining `ls` Options**

- **Options can be combined**, for example:
  - `-a -l` → long listing with hidden files
  - `-al` → same as above, shorthand version
  - `-alh` → same, but with human-readable file sizes

### **You can also specify one or more paths along with the options:**

- `ls -l /` → gives a **long listing** of the root directory
- `ls -R /home/antiemes/stuff` → **recursively lists** the specified directory

---

This slide explains how to **combine options** and **use them with paths** for more powerful usage of the `ls` command.

### **TL;DR – `ls -l` Long Listing Format**

- Example output:
  ```
  total 16
  -rw-r--r-- 1 antiemes users 2650 Feb  6 16:45 BlinkAppC.nc
  -rw-r--r-- 1 antiemes users 2924 Feb  6 16:45 BlinkC.nc
  drwxr-xr-x 3 antiemes users   60 Feb  6 16:45 build
  -rw-r--r-- 1 antiemes users   42 Feb  6 16:45 Makefile
  -rw-r--r-- 1 antiemes users  678 Feb  6 16:45 README.txt
  ```

- `total 16`: total disk space used (in blocks)
- Each line after that contains **7 columns**, showing:
  1. File type & permissions
  2. Number of links
  3. Owner
  4. Group
  5. File size (in bytes)
  6. Last modified date & time
  7. File or directory name

This is how you interpret detailed file information using `ls -l`.

### **The 7 Columns of `ls -l` Output**

Each line of `ls -l` contains these 7 fields:

1. **Type and permissions** (e.g., `-rw-r--r--`) – will be discussed later
2. **Link count** – number of hard links to the file/directory
3. **Owner** – the user who owns the file
4. **Group** – the group that owns the file
5. **Size in bytes** – can be changed to human-readable (`-h` option)
6. **Date** – last modification time (default)
7. **Name** – the filename or directory name

---

This slide breaks down the structure of a long listing in the terminal to understand each piece of information shown.


### **Entry Type (Bejegyzés típusa)**

- The **first character** in the `ls -l` output indicates the **type of file**, followed by three sets of **three characters** representing permissions.

---

### **File Types:**

| Symbol | Meaning                |
|--------|------------------------|
| `-`    | Regular file           |
| `d`    | Directory              |
| `l`    | Symbolic (soft) link   |
| `c`    | Character device       |
| `b`    | Block device           |
| `s`    | Socket                 |
| `p`    | FIFO (named pipe)      |

> `*` – Listed for completeness, not commonly used in daily tasks.

---

This slide helps you interpret the first character in a long listing (`ls -l`) to identify file types in Unix/Linux.

### **Permissions (Jogosultságok)**

---

- **Permissions are shown in 3 groups of 3 characters each:**
  - For **owner (u)**, **group (g)**, and **others (o)**

#### **Permission symbols:**
- `r` – read permission
- `w` – write permission
- `x` – execute permission
- `-` – permission **not granted**
- *(Other letters exist, but are not covered here.)*

---

- **Execute permission** has a special meaning for **directories**:  
  It means **you can enter (access) the directory**.

---

This slide explains how file and directory permissions work in Unix/Linux using symbolic notation.


### **Internal Documentation (Belső dokumentáció)**

---

#### **`man` (manual) command:**
- Usage: `man [section] command_or_topic`
- The output is displayed with **`less`** (or `more`), which allows **scrolling** and **searching**.

#### **Other help options:**
- Most programs also support:
  - `-h`
  - `-help`
  - `--help`  
  These often display useful information about usage and options.

#### **Manual pages are also available online.**

---

### **Examples:**
- `man ls` – help for the `ls` command  
- `man man` – help for using the `man` command itself  
- `man 7 regex` – documentation on **regular expressions** in section 7

---

This slide introduces built-in tools for accessing documentation directly from the command line.



### **Creating a Directory (`mkdir`)**

---

#### **Command syntax:**
```bash
mkdir path_to_directory
```

---

### **Explanation:**

- If the given path is **just one directory name**, it will be created in the **current directory**.

- If a **nested path** is specified (e.g., `a/b/c`), it will **only be created if the beginning parts already exist**.  
  - Use the `-p` option to **create all missing directories** in the path:
    ```bash
    mkdir -p a/b/c
    ```

- You can **create multiple directories at once** by listing them:
  ```bash
  mkdir dir1 dir2 dir3
  ```

---

This slide introduces `mkdir`, a basic but essential command for working with directories in Unix/Linux systems.



### **Creating Files Without Content (`touch`)**

---

#### **Command syntax:**
```bash
touch name1 [name2 [name3 ...]]
```

---

### **Key Points:**

- If the files **don’t exist**, they are **created empty**.
- If **no path** is given, the file is created in the **current directory**; otherwise, it’s placed at the specified location.
- If the file **already exists**, it is **not overwritten**, but its **last modified timestamp is updated**.

---

This command is useful for creating empty files quickly or updating timestamps on existing ones.


### **Copying Files (`cp`) – Part I**

---

#### **Command syntax:**
```bash
cp [options] source target
```

---

### **Behavior Overview:**

- There are multiple usage cases, but the logic is similar:
  - **The source is copied to the target location**

---

### **Common Scenarios:**

1. **Source: existing file, Target: new (non-existent) file**  
   - The target file is created and gets the same content as the source.

2. **Source: existing file, Target: existing file**  
   - The target file is **overwritten** with the source file’s content.

3. **Source: existing file(s), Target: existing directory**  
   - The file(s) are **copied into the target directory**.
   - If a file already exists there, it will be **overwritten**.

---

You can also specify full paths. If none is given, the current directory is used by default.


### **Copying Files (`cp`) – Part II**

---

### **Copying Directories**
- To copy directories, use the `-r` (or `--recursive`) option:
  - `-r` = recursive
  - Copies the **contents** of the directory as well

---

### **Using Wildcards (Shell Patterns) in Source Names**

- Wildcards can help match multiple files:
  - `*.txt` → copies all files ending in `.txt`
  - `*ab*` → copies files that **contain "ab"** in their names
  - `vala*` → copies files that **start with "vala"**
  - `*a*a*` → copies files that contain **two "a" letters**

> ⚠️ Important note:  
> These patterns are **expanded by the shell** into a list of matching files/directories **before** `cp` runs. So `cp` just receives a list of items to copy – just like if you listed them manually.

---

This slide expands on copying functionality and shows how to efficiently select multiple files using shell wildcards.


### **Displaying Text with `echo` – Part I**

---

#### **Basic usage:**
```bash
echo text
```

- Example:  
  `echo szoveg` → just prints the word `szoveg`

- Multiple words also work:  
  `echo ez tobb szavas` → prints: `ez tobb szavas`

---

### **Spacing behavior:**

```bash
echo itt     sok     space     van
```
- Output: `itt sok space van` → **extra spaces are collapsed**

---

### **Why?**
- `echo` treats each word as a **separate argument**.
- It prints all arguments separated by **a single space**.

---

### **Solution: Use quotes**
```bash
echo "itt     sok     space     van"
```
- The entire string is treated as **one argument**, so all spacing is preserved.

---

This slide explains how `echo` handles arguments and how to preserve formatting with quotation marks.



### **Displaying Text with `echo` – Part II**

---

### **Line Ending and Escape Sequences**

- By default, `echo` **adds a newline** at the end of the output.
  - Use `-n` to **suppress the newline**.

- Use `-e` to **enable interpretation of escape sequences**, such as:
  - `\t` → tab
  - `\n` → newline

---

### **Examples:**

```bash
echo -e "Ezt\tszepen\ttabulalva\tirja\tki."
```
→ Outputs the words separated by tabs.

```bash
echo -e "Minden\nszot\nuj\nsorba\nteszunk."
```
→ Puts each word on a **new line**.

---

This slide shows how to control formatting and special characters in terminal output using `echo`.



### **Shell Patterns (Wildcards)**

---

#### **Using `*` in commands like `echo` or `cp`:**
- `echo *` does **not print an asterisk**, but a **list of files and directories** in the current folder.
- The **shell replaces** the `*` with all matching filenames before the command runs.
- This applies to **other commands** too, like `cp` – they don’t see the `*`, they get a **list of files**.

---

### **How to prevent expansion (escape `*`):**

To print an actual asterisk, you can escape it:

```bash
echo "*"
echo '*'
echo \*
```

These commands **print the literal `*`** instead of expanding it into file names.

---

This slide explains shell expansion behavior and how to escape wildcard characters when needed.




Here’s a **TL;DR** summary of the slide titled **"Törlés (rm)"** (Deletion with `rm` command):

---

### `rm` [options] file_and_directory_list
- Comes from the word **"remove"**.
- Paths can be **absolute** or **relative**. Defaults to the current directory.
- **Shell patterns** (wildcards) are allowed.
- **Directories** can be deleted with the `-r` (recursive) option — this deletes the directory and all its contents.
- For **read-only files**, it asks for confirmation; otherwise, it deletes without prompting.
  - `-f`: **never asks**, force deletion.
  - `-i`: **always asks** before deleting.

---

Let me know if you want a quick command reference or example usage too!

Here's a TL;DR translation and summary of the slide content:

---

### 📁 Deleting a Directory (`rmdir`)

- **Syntax**: `rmdir directory [directory2 [directory3 …]]`
- **Important Notes**:
  - Only deletes **empty** directories.
  - Supports **relative** or **absolute** paths, as well as **shell patterns**.
    - Example: `rmdir *` deletes all **empty directories** in the current location, leaving others untouched.

---

Let me know if you want a comparison with `rm -r` or examples in a script.




Here's a TL;DR summary and translation of the slide:

---

### 🔄 Rename or Move (`mv`)

#### `mv source_file target_file`
- If the **source and target** are in the **same directory**, it **renames** the file.
- If they are in **different directories**, it **moves** the file.
- If the **target file exists**, it will be **overwritten**.

#### `mv source_files_and_dirs target_directory`
- Moves the listed **files and directories** into the **target directory**.
- **Shell patterns** can also be used here (e.g. `mv *.txt backup/`).

---

Let me know if you want command line examples or common use cases!


Here's a TL;DR summary and translation of the slide:

---

### 📄 Displaying File Content (`cat`)

#### `cat [file1 [file2 [file3 … ]]]`
- Name comes from **"concatenate"** (allegedly).
- Outputs the **contents of files in sequence**.
- Even this simple command has **many options** (e.g., it can **number lines**).
- Without parameters, it reads input from **standard input (stdin)**.
  - Press **Ctrl+D** to signal the end of input.

---

Let me know if you want examples of `cat` with options like `-n`, `-A`, or redirection.


Here’s a TL;DR summary and translation of the slide:

---

### 📖 Paginated Content Display (`less`, `more`)

#### `less file`
- Like `man`, lets you **scroll up/down**, **search**, etc.
- The `man` command actually **uses `less`** internally.

#### `more file`
- Similar to `less`.
- A bit **more limited** (the slide jokes: "a bit dumber").

---

Let me know if you want a quick keybinding cheat sheet for `less` or when to use `more` over `less`.


Here's a TL;DR summary and translation of the slide:

---

### 🔀 Output Redirection

#### ➤ `>` Redirect to file
- Most programs print to the screen — you can redirect this to a **file** with `>`.
- Example:
  - `ls -l > file`
  - `ls -R > file`  
  → Output goes into the file instead of the screen.
- ⚠️ If the file already exists, it will be **overwritten**!

#### ➤ `>>` Append to file
- Example:  
  `cat a*txt >> asok`  
  → Appends all files starting with "a" and ending in `.txt` to the **`asok`** file.

#### ➤ `cat > program.sh`
- Allows you to **type directly** into the file.
- You can also **paste content** from clipboard — very handy!

---

Let me know if you’d like quick practice tasks with redirection and appending.

Here’s a TL;DR summary and translation of the slide:

---

### ⬅️ Input Redirection

- Many programs expect **input from the keyboard**.
- We can redirect **standard input** so the program reads from a **file** instead.
- Syntax:  
  `program < file`
- Useful when **testing our own programs**.

✅ Example:  
`./example < input.txt`

---

Let me know if you want to combine this with output redirection (e.g., `program < input.txt > output.txt`).

Here’s a TL;DR summary and translation of the slide:

---

### 🔗 Linking Files – Part I: **Soft Link (Symbolic Link)**

- A **special file** that contains the **path** to another file.
- Using this link is usually equivalent to referencing the original file/directory.  
  → **Except** for operations like **rename** or **delete**.
- **Create with**:  
  `ln -s existing_file [target_dir or target_file]`
  - If target is a **file name** → link is created with that name.
  - If target is a **directory** → link is created in that directory using the original name.
- ⚠️ If the **original file is deleted**, the **link becomes broken** (content is lost).

---

Let me know if you’d like a demo comparing soft and hard links!

Here’s a TL;DR summary and translation of the slide:

---

### 🔗 Linking Files – Part II: **Hard Link**

- Creates **another filename** pointing to the **same file content**.
- **Command**:  
  `ln existing_file new_file`
- Deleting one does **not delete** the actual data — it remains as long as **one link exists**.
- The system uses a **link counter** to track how many links reference the same content.
- 🔒 Restrictions:
  - Can only be created **within the same filesystem**.
  - Cannot be created for **directories**.

---

Let me know if you want a table comparing hard vs soft links side by side.

Here’s a TL;DR summary and translation of the slide:

---

### 🔐 Modifying Permissions – Part I (`chmod`)

#### Syntax:
```bash
chmod modification file1 [file2 …]
```

#### Format of modification:
```bash
who [+|-] what
```

**Who:**
- `u` – user (owner)
- `g` – group
- `o` – others
- `a` – all

**What:**
- `r` – read permission
- `w` – write permission
- `x` – execute/access permission

**Operators:**
- `+` – add permission
- `-` – remove permission

✅ Example:  
`chmod u+x script.sh` → gives the owner execute permission on `script.sh`

---

Want help with symbolic vs numeric modes or examples with directories?

Here’s a TL;DR summary and translation of the slide:

---

### 🔐 Modifying Permissions – Part II (`chmod` continued)

#### ✅ Examples (symbolic mode):
- `u+x` – Give the **owner** execute permission
- `ug+w` – Give the **owner and group** write permission
- `a+x` – Give **everyone** execute permission
- `go-rwx` – Remove **all permissions** from **group and others**, keep owner’s

---

### 🧮 Setting Permissions Numerically (octal mode):
- Uses **3-digit octal** numbers:  
  `[owner][group][others]`
- Values:  
  - `r = 4`, `w = 2`, `x = 1` → summed per group

#### 🛠 Examples:
- `chmod 640 doksi.txt`  
  → Owner: read/write, Group: read, Others: none
- `chmod 777 pelda.sh`  
  → **Everyone can do everything**

---

Let me know if you want a quick permissions cheat sheet or a practice task!

Here’s a TL;DR summary and translation of the slide:

---

### 👤 Changing Ownership

#### `chown new_owner file1 [file2 …]`
- Changes the **owner** of the files to `new_owner`.

#### `chown new_owner:new_group file1 [file2 …]`
- Changes both the **owner** and the **group**.

#### `chgrp new_group file1 [file2 …]`
- Changes just the **group**.

🔁 Use `-R` for **recursive** changes — it will apply to all subdirectories and files too.

⚠️ **Admin (root) privileges** are required to perform these operations.

---

Let me know if you want a visual breakdown of ownership and permission fields in `ls -l` output!

Here’s a TL;DR summary and translation of the slide:

---

### 📄 File Start and End: `head` & `tail`

#### `head [-n number] file1 [file2 …]`
- Prints the **first `number` lines** of the file.
- If not specified, **defaults to 10 lines**.
- Shows the file name too (can be hidden with `-q`).

#### `tail [-n number] file1 [file2 …]`
- Same as `head`, but prints the **last `number` lines**.
- Supports shell patterns as well.

#### 🧪 Examples:
- `head -n 8 leiras.txt` → Displays the **first 8 lines** of `leiras.txt`
- `tail readme` → Displays the **last 10 lines** of `readme`

ℹ️ If no file is specified, input is read from **standard input** (keyboard, pipe, etc.)

---

Want examples with live log monitoring using `tail -f`?

Here’s a TL;DR summary and translation of the slide:

---

### 🔁 Pipe – Part I

- Programs that **write to standard output** and those that **read from standard input** can be **connected using a pipe (`|`)**.

#### 🧪 Examples:
- `ls -l | tail -n 5`  
  → Shows the **last 5 lines** of the `ls -l` output.
  
- `cat olvassel.txt | head -n 5`  
  → Displays the **first 5 lines** of `olvassel.txt`.

📝 Note:
- This is **almost** the same as `head -n 5 readme.txt`, but not exactly!
- When using a pipe, the receiving command (like `head`) does **not know the original file name** — only the data.  
  → That’s why it **can’t print the file name** when piped.

---

Want to continue to part II or see how to chain multiple pipes?

Here’s a TL;DR summary and translation of the slide:

---

### 🔁 Pipe – Part II

You can **chain multiple commands** using pipes:

#### 🧪 Examples:

- `cat pelda.txt | head -n 20 | tail -n 1`  
  → Takes the **first 20 lines** of `pelda.txt`, then selects the **last line** from that.  
  ✅ **Result:** line 20 of `pelda.txt`

- `ls -l | head -n 6 | tail -n 1`  
  → From the `ls -l` output, grabs the **6th line**.

---

📌 Piping is powerful for extracting precise parts of command outputs. Want more complex examples using `grep`, `awk`, or `cut`?

Here’s a TL;DR summary and translation of the slide:

---

### 🔢 Lines, Words, Characters Count (`wc`)

- `wc` = **word count**, but it also counts **lines** and **characters**.

#### 🧩 Options:
- `-l` → line count
- `-w` → word count
- `-c` → character count

✅ You can **combine options**, e.g.:
- `wc -wl file.txt` → counts **words and lines**

💡 **Default behavior**: prints **all three** (lines, words, characters).

---

Want a quick demo on piping output into `wc`, like `cat file | wc -l`?

Here’s a TL;DR summary and translation of the slide:

---

### 📊 `wc` – Part II

#### 🧩 Modes of operation:

✅ **Via Pipe**:
- `ls -1 | wc -l` → counts files/directories listed by `ls`
- `cat pelda.txt | wc -w` → counts **words** in `pelda.txt`
- In piped mode, `wc` **only shows the count**, **not the file name**.

✅ **Single file as argument**:
- `wc -c pelda.txt` → counts **characters** in `pelda.txt`
- Output includes the **count** and the **file name**.

✅ **Multiple files**:
- Lists counts **per file**, and a **total** at the end.
- Works with **lines, words, characters**, etc.
  
✅ **Shell wildcards** (e.g. `*.txt`) work here too.

---

Let me know if you'd like some combined examples with `find`, `xargs`, or `grep`.

Here’s a TL;DR summary and translation of the slide:

---

### ✂️ Cutting Fields (`cut`) – Part I

You can **cut text** either **by character** or **by field**.

#### 🔠 By Character:
- `cut -c start-end`  
  → returns characters in the range `[start, end]` from each line.
- `cut -c num1,num2,num3`  
  → returns specific character positions (e.g. 1st, 3rd, 5th).
- You can **combine** positions and ranges:  
  `cut -c 1,4-7,9`  
  → one specific, a range, and another specific character.

#### 🧪 Example:
- `ls -l | cut -c 2-10`  
  → Extracts the **permissions** field from `ls -l` output.

---

Would you like to see Part II for field-based cutting using delimiters (like `-d` and `-f`)?

Here’s a TL;DR summary and translation of the slide:

---

### ✂️ Cutting Fields (`cut`) – Part II (By Field)

#### 📌 Field-based cutting:

- `cut -d: -f 1,5 /etc/passwd`  
  → Cuts **fields 1 and 5** from `/etc/passwd` using **colon (`:`)** as the **delimiter**.

- `cut -f 1,3 lista_nagy.txt`  
  → Cuts **fields 1 and 3** from `lista_nagy.txt`, where fields are separated by **tabs** (default delimiter).

ℹ️ If no delimiter is specified, `cut` assumes **tabs** by default.

---

Let me know if you'd like a comparison with `awk` or `csvkit` for more complex field processing!

Here’s a TL;DR summary and translation of the slide:

---

### 🔢 Sorting (`sort`)

#### 📚 Basic usage:
- `cat nevek.txt | sort` → sorts lines **alphabetically**
- `sort nevek.txt` → same as above, no pipe needed

#### 🔑 Sort by specific field:
- `ls -l | sort -k 3` → sorts by the **3rd field** (e.g. owner)

#### 🔢 Numerical sorting:
- `ls -l | sort -n -k 5` → sorts by **file size**
- `ls -l | sort -n -k 5 -r` → sorts by size in **reverse order**

#### 🧠 More complex example:
- `ls -l | sort -k 5 -n | tail -n 1`  
  → shows the **largest file** in the listing

---

Let me know if you want examples for sorting CSV files or combining `sort` with `uniq`.

Here’s a TL;DR summary and translation of the slide:

---

### 🔁 Removing Duplicate Lines (`uniq`)

- If **identical lines appear consecutively**, `uniq` will keep **only one**.
- 🔄 **Sorting first** is useful, since `uniq` only removes **adjacent** duplicates.

#### 🧪 Example:
```bash
cat nevek.txt | sort | uniq
```

✅ Equivalent to:
```bash
sort -u nevek.txt
```

> `sort -u` = sort **and** remove duplicates in one step.

---

Let me know if you'd like to combine this with `wc`, `cut`, or `grep` for data cleanup!


Here’s a TL;DR summary and translation of the slide:

---

### 🔍 Filtering (`grep`) – Part I

- `grep` returns lines that **match a regular expression**.  
  *(Regex details will come on a later slide.)*

- You can check if a pattern **exists** in input even **without printing matches**.

- Searches are **case-sensitive** by default — use `-i` to make it **case-insensitive**.

#### 🧪 Usage:

**With a pipe:**
```bash
command | grep [options] pattern
```

**With a file:**
```bash
grep [options] pattern file
```

---

Let me know if you'd like help with common `grep` options like `-v`, `-r`, or `-n`!

Here’s a TL;DR summary and translation of the slide:

---

### 🔍 Filtering (`grep`) – Part II  
#### 🧬 Syntax Types (Regular Expressions)

#### 📘 Basic Regex Syntax
- Characters like `?`, `+`, `{`, `|`, `(`, `)` work as **normal characters** unless escaped.
- Use **`\?`, `\+`** etc. to enable their **meta** behavior.

#### 📗 Extended Regex Syntax
- Offers **more power** and convenience.
- Meta characters like `?`, `+`, `{` work **without** backslashes.
- Use with `grep -E` or `egrep`.

#### 📙 Perl Regex Syntax
- **Even more features**, e.g. `\w`, `\d`, `\s`.
- Use `grep -P` in **modern implementations**.

---

Want examples showing the difference between basic and extended syntax in practice?

Here’s a TL;DR summary and translation of the slide:

---

### 🔍 Filtering (`grep`) – Part III

#### 🧰 Useful Options:

- `-v` → **Invert match**: return lines **not** matching the pattern  
- `-e pattern` → Use this if your pattern **starts with a dash** (`-`), or to **combine multiple patterns**
- `-A num` → Show **num lines after** the matching line  
- `-B num` → Show **num lines before** the matching line  
- `-q` → **Quiet mode**: no output, but sets exit code (✅ useful in scripts)

---

### 📁 Filename Display:

- When using pipes or a **single file**, grep **doesn’t show the filename**.
- With **multiple files**, grep shows the **filename before each match**.
- Use `-H` to **force show** filenames, even with one file.  
- Use `-h` to **suppress** filenames in multi-file input.

---

Let me know if you want a visual cheat sheet or grep + regex exercises!

Here’s a TL;DR summary and translation of the slide:

---

### ⚙️ Processes and Jobs – Part I

#### 📁 The `/proc` virtual filesystem:

- Located at `/proc`, it's a **virtual filesystem** used to **interact with processes**.

- Contains **directories named by PID** (Process ID), each representing a running process.

- Inside each process's folder, you can find information like:
  - 🔓 Open files
  - 📊 Memory and CPU time stats
  - 👤 Owner
  - 🧠 Other state information

- Also contains **system-wide** directories and files for querying or configuring kernel settings.

---

Let me know if you’d like a tour of useful files like `/proc/cpuinfo`, `/proc/meminfo`, or `/proc/[pid]/status`.


Here’s a TL;DR summary and translation of the slide:

---

### ⚙️ Processes and Jobs – Part II

#### 📋 `ps` command — list and get info about processes

- Works based on the `/proc` virtual filesystem.

#### 🔧 Common options:
- `aux`  
  → Shows **all processes** with **full details**
- `w`, `ww`  
  → Enables **wide output** (shows full command with arguments)
- `f`  
  → Displays a **tree-like structure** (parent-child relationships)

#### 📊 The process list includes:
- Owner  
- PID  
- CPU and memory usage  
- Status  
- Name  
- And other details

---

Let me know if you’d like a comparison with `top`, `htop`, or `pstree`.
 

 Here’s a TL;DR summary and translation of the slide:

---

### ⚙️ Processes and Jobs – Part III  
#### 🔪 `kill` Command

- **Send signals to processes** using:
  ```bash
  kill [-signal_number | -signal_name] PID
  ```

#### 📌 Common signals:
- `15 (TERM)` – Politely **asks the process to terminate** (default, can be ignored)
- `9 (KILL)` – **Forcefully stops** the process (can’t be caught or ignored)
- `17, 19, 23 (STOP)` – **Pauses** the process
- `19, 18, 25 (CONT)` – **Resumes** the process

---

#### 🔫 `killall` Command:
- Syntax:
  ```bash
  killall [-signal_number | -signal_name] process_name
  ```
- Sends the signal to **all processes matching the given name** (instead of using PIDs)

---

Let me know if you want a cheat sheet of all common signals (`kill -l`) or signal-handling in C!


Here’s a TL;DR summary and translation of the slide:

---

### ⚙️ Processes and Jobs – Part IV  
#### 🧠 Managing jobs in the terminal

You can run **multiple programs as jobs** in the terminal.  
At most, **one job is in the foreground** at any time.

#### 🧰 Useful commands:

- `jobs`  
  → Lists all **current jobs**

- `bg [number]`  
  → Puts the **current or specified job** in the **background**

- `fg [number]`  
  → Brings the **current or specified job** to the **foreground**

- `kill %number`  
  → Sends a signal to a **job** using the **job ID** (not PID), prefixed with `%`

---

Let me know if you want to explore job control shortcuts like `Ctrl+Z`, `&`, or use cases!


Here’s a TL;DR summary and translation of the slide:

---

### ⚙️ Processes and Jobs – Part V

#### ▶️ Running a program in the background:
- Example:
  ```bash
  xterm &
  ```
  The `&` runs the command **in the background**.

#### 🛑 Pausing an active process:
- Press **`Ctrl+Z`** to **suspend** the current foreground process.

Then you can:
- Use `fg` to bring it **back to foreground**
- Use `bg` to resume it **in the background**

⚠️ Some programs **disable this feature** and cannot be suspended this way.

---

Let me know if you want a quick summary of job states or signals that affect them!

